<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>系统移植笔记</title>
    <link href="/2022/System-Transplantion/"/>
    <url>/2022/System-Transplantion/</url>
    
    <content type="html"><![CDATA[<p>将Linux系统移植到ARM核的开发板</p><span id="more"></span><h1 id="PC-和-嵌入式设备-系统启动比较"><a href="#PC-和-嵌入式设备-系统启动比较" class="headerlink" title="PC 和 嵌入式设备 系统启动比较"></a>PC 和 嵌入式设备 系统启动比较</h1><h2 id="PC机启动过程"><a href="#PC机启动过程" class="headerlink" title="PC机启动过程"></a>PC机启动过程</h2><blockquote><ol><li><strong>BIOS</strong> (Basic Inpu Output System)     ( 硬件初始化 : 系统时钟，内存(SDRAM/DDR2/DDR3/DDR4)，启动方式:USB 硬盘 光驱 …)</li><li><strong>引导程序</strong> (grub,lilo,…) =&gt;加载操作系统</li><li><strong>OS</strong>       (windows,Linux,Mac os)</li><li><strong>挂载文件系统</strong> ( NTFS, FAT(16/32), EXT(2,3,4) )</li><li><strong>应用程序</strong></li></ol></blockquote><h2 id="嵌入式设备（exynos4412）"><a href="#嵌入式设备（exynos4412）" class="headerlink" title="嵌入式设备（exynos4412）"></a>嵌入式设备（exynos4412）</h2><blockquote><ol><li><p>iROM固化代码</p><blockquote><ul><li><p>基本硬件初始化</p></li><li><p>判别启动方式—(SD/USB/EMMC)</p></li><li><p>读取存储介质<strong>一部分数据</strong>到 iRAM </p></li></ul></blockquote></li><li><p>iRAM代码运行bootloader<strong>第一阶段</strong></p><blockquote><ul><li>初始化系统时钟</li><li>初始化内存</li><li>自搬移bootloader到内存</li></ul></blockquote></li><li><p>内存中运行bootloader<strong>第二阶段</strong></p><blockquote><ul><li><p>初始化基本的硬件设备  (串口,EMMC,SD)</p></li><li><p>加载OS到内存</p></li></ul></blockquote></li><li><p>内存中运行操作系统  (Linux,windows CE,Mac OS)</p></li><li><p>挂载文件系统 </p></li><li><p>运行应用程序 </p></li></ol></blockquote><p><strong>bootloader = BIOS + 引导程序</strong></p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/System_Start.png" style="zoom:80%;" /><table><thead><tr><th>Item</th><th>Description</th></tr></thead><tbody><tr><td>iROM</td><td>internal Read-Only Memory — 掉电后数据保留</td></tr><tr><td>iRAM</td><td>internal Random-Access Memory — 掉电后数据丢失</td></tr><tr><td>LPDDR</td><td>Low-Power Double Data Rate （SDRAM —- Synchronous Dynamic Random-Access Memory）</td></tr><tr><td>eMMC</td><td>Embedded Multi Media Card</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li><p>硬件：fs4412开发板 — Samsung Exynos芯片</p></li><li><p>PC机环境：Ubuntu 16.04</p></li><li><p>交叉开发概念：</p><blockquote><p>在PC机完成代码的编写和编译，在开发板运行编译完成的程序</p></blockquote></li></ul><h1 id="Linux-环境配置"><a href="#Linux-环境配置" class="headerlink" title="Linux 环境配置"></a>Linux 环境配置</h1><h2 id="在-Linux-上添加交叉开发工具链"><a href="#在-Linux-上添加交叉开发工具链" class="headerlink" title="在 Linux 上添加交叉开发工具链"></a>在 Linux 上添加交叉开发工具链</h2><ul><li>方式一：在当前终端添加环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:TOOL_CHAIN <br><span class="hljs-comment"># TOOL_CHAIN 是交叉开发工具链的绝对路径</span><br><span class="hljs-comment"># 这种方式仅对当前终端有效</span><br></code></pre></div></td></tr></table></figure><ul><li><p>方式二：添加环境变量到配置文件 （<strong>选择这种</strong>）</p><blockquote><ul><li>/home/linux (用户名）/.bashrc —– (针对当前登录用户)   </li><li>/etc/bash.bashrc —- (所有用户有效)  （<strong>选这个</strong>）</li></ul></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/bash.bashrc<br><span class="hljs-comment"># 在文件末尾添加</span><br>TOOL_CHAIN=/home/linux/fs4412/toolchain/gcc-4.6.4/bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$TOOL_CHAIN</span><br><span class="hljs-comment"># TOOL_CHAIN 根据自己工具链文件的绝对路径，每个人不一样</span><br></code></pre></div></td></tr></table></figure><p>如果是64bit 的Ubuntu系统，需要安装32bit运行库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt install lib32ncurses5<br>sudo apt install lib32z1<br></code></pre></div></td></tr></table></figure><h2 id="Linux-服务配置"><a href="#Linux-服务配置" class="headerlink" title="Linux 服务配置"></a>Linux 服务配置</h2><h3 id="配置tftp服务-（文件传输）"><a href="#配置tftp服务-（文件传输）" class="headerlink" title="配置tftp服务 （文件传输）"></a>配置tftp服务 （文件传输）</h3><ol><li><p>安装软件包：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install tftp-hpa  (客户端程序)<br>sudo apt-get install tftpd-hpa （服务端程序）<br></code></pre></div></td></tr></table></figure></li><li><p>修改默认配置文件  /etc/default/tftp-hpa </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/default/tftp-hpa<br><span class="hljs-comment"># 修改 TFTP_DIRECTORY=&quot;自己的tftpboot路径&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>重启tftp 服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/tftpd-hpa restart<br><span class="hljs-comment"># 或者</span><br>sudo service tftpd-hpa restart<br></code></pre></div></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tftp 127.0.0.1 (server IP)<br>tftp&gt; get (下载文件)<br>tftp&gt; quit<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="配置nfs-（network-file-system）服务"><a href="#配置nfs-（network-file-system）服务" class="headerlink" title="配置nfs （network file system）服务"></a>配置nfs （network file system）服务</h3><ol><li><p>安装软件包:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install nfs-kernel-server<br></code></pre></div></td></tr></table></figure></li><li><p>修改默认配置文件 /etc/exports</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/exports<br><span class="hljs-comment"># 添加自己电脑上需要共享的目录路径</span><br>/home/linux/fs4412/rootfs *(rw,sync,no_root_squash)<br><span class="hljs-comment"># *前面有空格，*后面部分代表目录的权限设置</span><br><span class="hljs-comment"># rw : 读写权限</span><br><span class="hljs-comment"># sync : 文件同步</span><br><span class="hljs-comment"># no_root_squash : 不对root用户进行权限压缩</span><br></code></pre></div></td></tr></table></figure></li><li><p>重新启动nfs服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo /etc/init.d/nfs-kernel-server restart<br><span class="hljs-comment"># 或者</span><br>sudo service nfs-kernel-server restart<br></code></pre></div></td></tr></table></figure></li><li><p>测试:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo mount IP:共享路径  自己的挂载点目录<br><span class="hljs-comment"># e.g.</span><br>sudo mount 127.0.0.1:/home/linux/fs4412/rootfs  ./nfs<br><span class="hljs-comment"># ./nfs (自己电脑上当前目录下的nfs子目录)</span><br><br>sudo umount ./nfs<br><span class="hljs-comment"># 撤销对nfs目录的挂载</span><br></code></pre></div></td></tr></table></figure></li></ol><h1 id="开发板环境配置"><a href="#开发板环境配置" class="headerlink" title="开发板环境配置"></a>开发板环境配置</h1><h2 id="u-boot-常用命令"><a href="#u-boot-常用命令" class="headerlink" title="u_boot 常用命令"></a>u_boot 常用命令</h2><ol><li><p>设置开发板ip地址</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">setenv ipaddr [ip]<br><span class="hljs-built_in">print</span> 查看板子环境信息<br>save 记得保存<br></code></pre></div></td></tr></table></figure></li><li><p>设置tftp 服务器的ip地址</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">setenv serverip [server IP] <br></code></pre></div></td></tr></table></figure></li><li><p>开发板和Ubuntu之间进行网络通信 （板子 Ping Ubuntu）</p><blockquote><p>&lt;1&gt;板子IP地址和Ubuntu的IP地址的网络号一样<br>&lt;2&gt;虚拟机桥接模式<br>&lt;3&gt;无线网卡禁用<br>&lt;4&gt;防火墙关闭</p></blockquote></li><li><p>用tftp服务，下载Linux 系统、设备树（硬件信息）、文件系统 到开发板上</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tftp 41000000 uImage  <br>tftp 42000000 exynos4412-fs4412.dtb<br>tftp 43000000 ramdisk.img<br></code></pre></div></td></tr></table></figure></li><li><p>启动内存</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">bootm 内核在内存地址  ramdisk在内存地址  设备树在内存地址<br>bootm 41000000  43000000   42000000<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="网络方式加载Linux内核-开发阶段"><a href="#网络方式加载Linux内核-开发阶段" class="headerlink" title="网络方式加载Linux内核(开发阶段)"></a>网络方式加载Linux内核(开发阶段)</h1><h1 id="从EMMC加载内核和文件系统-产品发布阶段"><a href="#从EMMC加载内核和文件系统-产品发布阶段" class="headerlink" title="从EMMC加载内核和文件系统(产品发布阶段)"></a>从EMMC加载内核和文件系统(产品发布阶段)</h1><h1 id="编译Linux-Kernel"><a href="#编译Linux-Kernel" class="headerlink" title="编译Linux Kernel"></a>编译Linux Kernel</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>Linux</tag>
      
      <tag>系统移植</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt笔记</title>
    <link href="/2022/Qt-Note/"/>
    <url>/2022/Qt-Note/</url>
    
    <content type="html"><![CDATA[<p>Qt 信号与槽、内存管理等基本机制；Qt 网络编程； Qt 元对象系统</p><span id="more"></span><h1 id="Qt信号与槽"><a href="#Qt信号与槽" class="headerlink" title="Qt信号与槽"></a>Qt信号与槽</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>实现对象和对象之间的通信</strong>，当一个对象发生改变会发送一个信号通知另一个对象执行一个函数，这个函数称之为槽</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号的声明：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">signals:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signaleA</span><span class="hljs-params">()</span></span>;<br>...<br></code></pre></div></td></tr></table></figure><p>信号只需要声明，不需要定义</p><p>信号的发送：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">emit <span class="hljs-title">signalA</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><h2 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h2><p>槽的声明：只在头文件进行，关键字：<code>slots</code>, 声明槽函数后必须实现 在.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> slots:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slotA</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//实现和普通函数没有区别</span><br></code></pre></div></td></tr></table></figure><p>实现：在对应源文件中，必须实现</p><p>调用：</p><blockquote><p>信号调用：与槽函数关联的信号被发送时，槽函数被调用</p><p>普通调用：通过函数名或函数指针调用</p></blockquote><h2 id="信号与槽的连接"><a href="#信号与槽的连接" class="headerlink" title="信号与槽的连接"></a>信号与槽的连接</h2><h3 id="连接方式："><a href="#连接方式：" class="headerlink" title="连接方式："></a>连接方式：</h3><blockquote><ul><li>手动连接：</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&gt;<span class="hljs-built_in">connect</span>(Obj_sender, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">my_signal</span>()), Obj_receiver, <span class="hljs-built_in">SLOT</span>(), ConnectType);<br></code></pre></div></td></tr></table></figure><p>最后一个参数，可以省略，默认为：自动方式</p><ul><li>自动连接：通过命名连接</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyClass::on_obj_signal</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//槽函数</span><br>&gt;on_发送信号的对象名_发送的信号（）<br></code></pre></div></td></tr></table></figure></blockquote><h3 id="连接规则："><a href="#连接规则：" class="headerlink" title="连接规则："></a>连接规则：</h3><ul><li>信号的参数可以比槽函数多，反之不可以</li><li>信号与槽，可以一对一，一对多，多对一</li><li>信号与信号也可以连接：发起方信号参数要多于接收方，连接成功后，触发接收方信号不会触发发起方信号</li><li>连接可以被删除：<code>disconnect</code></li><li>同一个连接可以绑定多次，触发以此信号会执行多个槽函数，执行顺序按照绑定顺序</li></ul><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><ul><li><strong>直连方式</strong>(DirectConnection)：槽函数在信号发送时候，直接被调用，（建议）槽函数运行于信号发送者的线程</li><li><strong>排队方式</strong>(QueuedConnection)：（建议）槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者当前函数执行完，进入事件循环，槽函数被调用</li><li><strong>自动方式</strong>(AutoConnection)：默认方式，如果接收者和发送者在同一线程，自动调用直连方式，在不同线程，自动调用排队方式</li><li><strong>阻塞排队方式</strong>(BlockingQueuedConnection)：槽函数调用时机和排队方式一致，不过发送完信号后，发送者所在线程会阻塞，直到槽函数运行完。<strong>发送者和接收者绝不能在一个线程，否则死锁</strong></li><li><strong>唯一连接方式</strong>(UniqueConnection)：和前面几个结合使用，这个flag可以通过按位或（|），和以上四个结合使用。当设置这个flag时候，某个信号和槽已经连接时，再重连就失败，避免重复连接。</li></ul><h1 id="Qt元对象系统"><a href="#Qt元对象系统" class="headerlink" title="Qt元对象系统"></a>Qt元对象系统</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Qt元对象系统提供对象间的通信机制：信号与槽，以及运行时类型信息和动态属性系统的支持，是对标准C++ 的拓展，使Qt更好的实现GUI图形用户界面编程</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><p>QObject</p></li><li><p>类声明私有段中Q_OBJECT宏</p></li><li><p>元对象编译器（moc）</p><blockquote><p>moc 工作流程：</p><ul><li>确认类继承自QObject</li><li>寻找Q_OBJECT宏</li><li>类的一般信息</li><li>Qt关键字（slots、signals）</li></ul><p>moc从头文件获取数据，编译成moc文件，再和.cpp编译的文件共同生成中间代码文件</p></blockquote></li></ul><h1 id="Qt的几种机制"><a href="#Qt的几种机制" class="headerlink" title="Qt的几种机制"></a>Qt的几种机制</h1><ul><li><p>内存管理机制</p><p>Qt的内存管理机制，让Qt定义的类，继承一个父类，父类作为管理者管理子类，当父类销毁，子类跟着销毁</p><p>两个类继承 <code>QObject</code>，且有<code>Q_OBJECT</code> 宏</p></li><li><p>信号与槽机制</p><p>实现对象与对象间的通信</p></li><li><p>事件机制</p></li></ul><h1 id="Qt实现Http通信"><a href="#Qt实现Http通信" class="headerlink" title="Qt实现Http通信"></a>Qt实现Http通信</h1><h2 id="Http协议数据格式"><a href="#Http协议数据格式" class="headerlink" title="Http协议数据格式"></a>Http协议数据格式</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/HttpFormat.png" style="zoom:150%;" /><h2 id="请求数据方式"><a href="#请求数据方式" class="headerlink" title="请求数据方式"></a>请求数据方式</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/HttpRequest.png" style="zoom:80%;" /><ul><li><p>GET 是http协议的默认请求方法，日常使用GET方法来提交表单数据。</p><p>但GET方法的表单数据只经过简单的编码，同时作为URL的一部分向Web服务器发送，存在安全隐患，此外提交的数据量不能太大</p></li><li><p>POST 是GET方法的代替，克服了GET方法不安全和数据量小的缺点。</p><p>POST方法，将数据作为标准数据发送给Web服务器，放在附属体中，更加安全且可以调教大批量数据</p></li></ul><h2 id="Qt实现Http通信常用类"><a href="#Qt实现Http通信常用类" class="headerlink" title="Qt实现Http通信常用类"></a>Qt实现Http通信常用类</h2><ul><li><p>QNetworkRequest — 网络连接请求类</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">QNetworkRequest <span class="hljs-title">netWorkRequest</span><span class="hljs-params">(QUrl(<span class="hljs-string">&quot;https://l-by.cn/yinyue/api.php&quot;</span>))</span></span>; <span class="hljs-comment">//URL地址</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">netWorkRequest.<span class="hljs-built_in">setRawHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>); <span class="hljs-comment">//标头</span><br></code></pre></div></td></tr></table></figure></blockquote></li><li><p>QNetworkAccessManager — 网络访问管理器</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">QString body = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;types=search&amp;count=100&amp;source=netease&amp;pages=1&amp;name=%1&quot;</span>).<span class="hljs-built_in">arg</span>(searchData);<span class="hljs-comment">//附属体</span><br>QNetworkReply *networkReply = netWorkAccessMangager-&gt;<span class="hljs-built_in">post</span>(netWorkRequest,body.<span class="hljs-built_in">toUtf8</span>()); <span class="hljs-comment">//让网络管理类通过POST方式发送请求，返回一个网络回复类指针</span><br></code></pre></div></td></tr></table></figure></blockquote></li><li><p>QNetworkReply — 网络回复类</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">networkReply-&gt;<span class="hljs-built_in">readAll</span>(); <span class="hljs-comment">//读取所有数据返回一个QByteArray</span><br><span class="hljs-built_in">readLine</span>(qint64 maxSize = <span class="hljs-number">0</span>);<span class="hljs-comment">//按行读取 </span><br><span class="hljs-built_in">read</span>(<span class="hljs-keyword">char</span> *data, qint64 maxSize);<span class="hljs-comment">//读取最大字节为maxSize,存到data中，返回读取到的字节数</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">signals:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readRead</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//网络中有数据发送给你触发该信号</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//所有数据接收完成触发该信号</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(QNetworkReply::NetworkError code)</span></span>; <span class="hljs-comment">//网络连接出错触发该信号</span><br></code></pre></div></td></tr></table></figure></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/Git-Command/"/>
    <url>/2022/Git-Command/</url>
    
    <content type="html"><![CDATA[<!-- 转载 --><p>作者: 阮一峰 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">博客地址</a></p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class="hljs-comment"># 下载一个项目和它的整个代码历史</span><br>$ git <span class="hljs-built_in">clone</span> [url]<br></code></pre></div></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加\删除文件"></a>增加\删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [dir]<br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git rm [file1] [file2] ...<br><br><span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git rm --cached [file]<br><br><span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br>$ git mv [file-original] [file-renamed]<br></code></pre></div></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></div></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>$ git branch<br><br><span class="hljs-comment"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class="hljs-comment"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class="hljs-comment"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class="hljs-comment"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></div></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>$ git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></div></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span><br>$ git status<br><br><span class="hljs-comment"># 显示当前分支的版本历史</span><br>$ git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>$ git <span class="hljs-built_in">log</span> -S [keyword]<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class="hljs-built_in">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>$ git <span class="hljs-built_in">log</span> -p [file]<br><br><span class="hljs-comment"># 显示过去5次提交</span><br>$ git <span class="hljs-built_in">log</span> -5 --pretty --oneline<br><br><span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class="hljs-comment"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class="hljs-comment"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class="hljs-comment"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></div></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></div></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br>$ git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br>$ git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></div></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM基础笔记</title>
    <link href="/2022/ARM-Note/"/>
    <url>/2022/ARM-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="产业链"><a href="#产业链" class="headerlink" title="产业链"></a>产业链</h1><ul><li>CUP核</li><li><strong>SOC芯片 — System On Chip （CPU核 + 外围控制器）</strong></li><li>产品</li></ul><h1 id="ARM核工作模式（USA-UFI-SM）"><a href="#ARM核工作模式（USA-UFI-SM）" class="headerlink" title="ARM核工作模式（USA UFI SM）"></a>ARM核工作模式（USA UFI SM）</h1><h2 id="八大工作模式"><a href="#八大工作模式" class="headerlink" title="八大工作模式"></a>八大工作模式</h2><h3 id="用户模式（USR：User）—-唯一非特权"><a href="#用户模式（USR：User）—-唯一非特权" class="headerlink" title="用户模式（USR：User）— 唯一非特权"></a>用户模式（USR：User）— 唯一非特权</h3><ul><li>用户程序的工作模式，运行在<strong>操作系统的用户态</strong>，<strong>没有操作其他硬件的权限</strong></li><li><strong>只有它不是特权模式（privilege mode）</strong></li><li>只能执行处理自己的数据，不能切换到其他模式下，<strong>访问硬件资源</strong>或<strong>切换到其他模式</strong>只能通过<strong>软中断或者异常</strong></li></ul><h3 id="系统模式（SYS：System）—-特权"><a href="#系统模式（SYS：System）—-特权" class="headerlink" title="系统模式（SYS：System）— 特权"></a>系统模式（SYS：System）— 特权</h3><ul><li><strong>不受用户模式的限制</strong>，用户模式核系统模式共用一套寄存器</li><li>操作系统的一些特权任务，可以用该模式访<strong>问一些受控资源</strong></li></ul><h3 id="终止模式（ABT：Abort）—-异常"><a href="#终止模式（ABT：Abort）—-异常" class="headerlink" title="终止模式（ABT：Abort）— 异常"></a>终止模式（ABT：Abort）— 异常</h3><ul><li>用域支持<strong>虚拟内存或存储器保护</strong></li><li><strong>用户程序访问非法地址、没有权限的地址，进入该模式</strong>（如：段错误）</li></ul><h3 id="未定义模式（UDF：Undefined）—-异常"><a href="#未定义模式（UDF：Undefined）—-异常" class="headerlink" title="未定义模式（UDF：Undefined）— 异常"></a>未定义模式（UDF：Undefined）— 异常</h3><ul><li>用于支持硬件协处理器的软件仿真</li><li><strong>CPU在指令的译码阶段不能识别该指令操作</strong>时，进入该模式</li></ul><h3 id="快速中断模式（FIQ：Fast-Interrupt-Request）—-异常"><a href="#快速中断模式（FIQ：Fast-Interrupt-Request）—-异常" class="headerlink" title="快速中断模式（FIQ：Fast Interrupt Request）— 异常"></a>快速中断模式（FIQ：Fast Interrupt Request）— 异常</h3><ul><li>用于处理对<strong>时间要求紧急的中断请求</strong>， 主要用于<strong>高速数据传输及通道处理</strong></li></ul><h3 id="一般中断模式（IRQ：Interrupt-Request）—-异常"><a href="#一般中断模式（IRQ：Interrupt-Request）—-异常" class="headerlink" title="一般中断模式（IRQ：Interrupt Request）— 异常"></a>一般中断模式（IRQ：Interrupt Request）— 异常</h3><ul><li>也叫普通中断，用于<strong>处理一般中断请求，通常在硬件产生中断信号会自动进入该模式</strong></li><li>可以自由访问系统硬件资源</li></ul><h3 id="管理模式（SVC：Supervisor）—-异常"><a href="#管理模式（SVC：Supervisor）—-异常" class="headerlink" title="管理模式（SVC：Supervisor）— 异常"></a>管理模式（SVC：Supervisor）— 异常</h3><ul><li>CPU上电后的默认模式，主要用作<strong>系统初始化（复位异常），软中断处理</strong></li><li><strong>用户模式下，用户程序请求使用硬件资源时，通过软中断进入该模式</strong></li></ul><h3 id="安全监控模式（MON：Monitor）"><a href="#安全监控模式（MON：Monitor）" class="headerlink" title="安全监控模式（MON：Monitor）"></a>安全监控模式（MON：Monitor）</h3><ul><li><strong>TrustZone — 讲SOC的硬件和软件资源划分程安全和非安全两个世界</strong></li><li>安全世界：所有需要保密的操作 — 指纹识别、密码处理、数据加解密等</li><li>非安全世界：用户操作系统、各种应用程序</li><li>两个世界通过Monitor Mode的模式进行转换</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>唯一非特权：User</li><li>五大异常模式：ABT、UDF、FIQ、IRQ、SVC</li><li>安全模式：MON</li><li>中断和异常的区别：异常包含了中断，中断只是异常的一种</li></ul><h1 id="寄存器资源"><a href="#寄存器资源" class="headerlink" title="寄存器资源"></a>寄存器资源</h1><h2 id="寄存器分类-（Registers）"><a href="#寄存器分类-（Registers）" class="headerlink" title="寄存器分类 （Registers）"></a>寄存器分类 （Registers）</h2><ul><li><p><strong>ARM态</strong>通用寄存器和程序计数器 — R0~R15</p></li><li><p><strong>ARM态</strong>程序状态寄存器 — CPSR、SPSR</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/ARM_Registers.png" style="zoom: 67%;" /><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li><p><strong>R0~R10</strong> — 存放用户数据</p></li><li><p><strong>R11</strong> （fp：frame-pointer）— 栈帧指针 记录一个<strong>栈空间的起始地址</strong></p></li><li><p><strong>R12</strong>（ip：The Intra-Procedure-call scratch register）— <strong>临时存储sp</strong>（R13）</p></li><li><p><strong>R13</strong>（sp：stack pointer）— <strong>栈指针寄存器， 栈空间的结束地址</strong></p></li><li><p><strong>R14</strong>（lr：link register）— <strong>发送跳转，保存PC寄存器的值</strong></p></li><li><p><strong>R15</strong>（pc：program counter）— <strong>程序计数器，存放CPU需要执行的下一条指令的内存地址</strong></p></li><li><p><strong>CPSR</strong>（Current Program Status Register）— 记录当前CPU状态</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/CPSR.png" style="zoom: 67%;" /></blockquote></li><li><p><strong>SPSR</strong>（Saved Program Status Register）— 异常产生时候，保存CPSR的值</p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>ARM寄存器 — 40个，一种模式最多 —18个寄存器</p></li><li><p>所有模式共享 — R0~R7、R15、CPSR</p></li><li><p>除FIQ其他模式共享 — R8~R12</p></li><li><p>5大异常模式私有 — R13~R14、SPSR</p></li><li><p>MON私有 — R13~R14、SPSR</p></li><li><p><strong>FIQ — 中断更快的三大原因</strong></p><blockquote><ul><li>更多私有寄存器，私有寄存器使用不需要做保护，FIQ恢复现场更快</li><li>FIQ在异常向量表的最高位，省去了跳转的过程，速度更快</li><li>FIQ的处理优先级比IRQ更高，甚至可以打断正在执行的IRQ</li></ul></blockquote></li><li><p><strong>User 和System模式没有SPSR</strong>，因为它们产生异常时，跳转到其他模式执行，是他们的状态被其他模式保存</p></li></ul><h1 id="常用ARM核指令"><a href="#常用ARM核指令" class="headerlink" title="常用ARM核指令"></a>常用ARM核指令</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><code>&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125;     &lt;Rd&gt; ,&lt;Rn&gt;&#123;, &lt;operand2&gt;&#125;</code></p><ul><li><p>opcode : 操作码 </p></li><li><p>cond ：条件</p><blockquote><ul><li>NE、EQ、GT、LT、GE、LE</li></ul></blockquote></li><li><p>S：指令执行结果，影响CPSR的N，Z，C，V</p></li><li><p>Rd：目标寄存器，存放指令执行结果R0~R15</p></li><li><p>Rn：操作数1，必须是寄存器</p></li><li><p>operand2：操作数2</p><blockquote><ul><li><p>立即数：<code>#100</code> ,一个常数，一个8位常数通过循环右移偶数位，得到它，则该数字为合法立即数</p><blockquote><p>把一个数转换为32bit，16进制</p><ul><li>除零外，仅有一位数，为合法立即数</li><li>除零外，仅有两位数，且相邻（包括首尾），为合法立即数</li><li>除零外，仅有三位数字，且相邻（包括中间有0，首尾相邻），这三位数，最高位只能取1、2、3；最低位只能取4、8、C，这样的组合为合法立即数</li></ul></blockquote></li><li><p>寄存器</p></li><li><p>寄存器移位：只能寄存器移位</p><blockquote><ul><li>LSL:逻辑左移</li><li>LSR:逻辑右移</li><li>ASR:算数右移</li></ul></blockquote></li></ul></blockquote></li></ul><p><strong>注意：操作数1，只能是寄存器</strong></p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><ul><li><p>MOV：<code>MOV 目标寄存器，操作数2</code></p><blockquote><p>将操作数2的值 赋值给目标寄存器</p></blockquote></li><li><p>MVN：<code>MVN 目标寄存器 , 操作数2</code></p><blockquote><p>将操作数2 取反的值，给目标寄存器</p></blockquote></li><li><p>LDR：<code>LDR 目标寄存器， =数据</code></p><blockquote><p>任意数据传送到目标寄存器</p><ul><li>如果后面是一个合法立即数，翻译成MOV指令</li><li>如果是非法立即数，翻译成 LDR Rn, [PC]</li></ul></blockquote></li></ul><p><strong>注意：</strong> <strong>MOV指令 用立即数</strong>，<strong>效率更高</strong>，CPU获取指令时，指令和数据都翻译成机器码，指令和数据同时获取，因此效率更高</p><p>但，不是所有数据都能被和指令同时获取，因此，有了合法立即数的概念，一条指令中八位是数据位</p><h2 id="数据计算指令"><a href="#数据计算指令" class="headerlink" title="数据计算指令"></a>数据计算指令</h2><ul><li><p>ADD：<code>ADD 目标寄存器，操作数1，操作数2</code></p></li><li><p>SUB：<code>SUB 目标寄存器，操作数1，操作数2</code></p></li><li><p>MUL：<code>目标寄存器, 操作数1，操作数2</code></p><blockquote><p><strong>注意：MUL的目标寄存器，和操作数1，编号不能相同</strong></p><p><strong>MUL 两个操作数都要是简单寄存器</strong></p></blockquote></li></ul><h2 id="位运算指令"><a href="#位运算指令" class="headerlink" title="位运算指令"></a>位运算指令</h2><ul><li><p>AND：<code>AND 目标寄存器，操作数1，操作数2</code></p><blockquote><p>将操作数1，<strong>按位与</strong> ，操作数2，结果存放在目标寄存器</p></blockquote></li><li><p>ORR：<code>ORR 目标寄存器，操作数1，操作数2</code></p><blockquote><p>操作数1，按位或，操作数2，结果存放在目标寄存器</p></blockquote></li><li><p>EOR：<code>EOR 目标寄存器， 操作数1，操作数2</code></p><blockquote><p>将操作数1，按位异或，操作数2，结果放在目标寄存器</p></blockquote></li><li><p>BIC：<code>BIC 目标寄存器，操作数1，操作数2</code></p><blockquote><p>目标寄存器 = 操作数1 &amp; ~操作数2</p></blockquote><p>如果想把data的某些位，变成自己想要的值：</p><ul><li><p><strong>先将对应的位清0，然后再或上对应的值（对应的值左移得到）</strong></p></li><li><blockquote><p>清0：先对应位数，几位就几个1，从第几位开始，就左移几位，再取反，再和源数字按位与&amp;</p><p>置1：目标数字，左移，从第几位开始就左移几位，再和源数字按位或 |</p></blockquote></li></ul></li></ul><h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><ul><li><p>CMP：<code>CMP 寄存器，操作数2</code></p><blockquote><p>CMP指令会自动影响CPSR的N、Z、C、V</p><p>CMP执行时不关心之前执行了什么指令，只关心CPSR的NZCV表示的条件是否满足条件，满足执行，不满足不执行</p></blockquote></li></ul><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul><li><p>B/BL ：只能跳转+/- 32M范围，跳转到一个指定标签</p><blockquote><p><code>B 标签</code></p><p><code>BL 标签</code> ：BL跳转之前，将跳转前的PC（R15）值保存在LR（R14）</p></blockquote></li><li><p>给PC赋值：没有范围限制</p><p><code>LDR PC , =标签名</code></p></li></ul><h2 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h2><h3 id="单个数据访问"><a href="#单个数据访问" class="headerlink" title="单个数据访问"></a>单个数据访问</h3><ul><li><p>LDR（Load Register）：将内存的值加载到寄存器（读内存）</p></li><li><p>STR（Store Register）：将寄存器的值写入内存（写内存）</p></li><li><p><strong>寄存器间接寻址：</strong></p><blockquote><ul><li>LDR r0, <strong>[r1]</strong> —-&gt; (r0 = *r1)</li><li>STR r0，**[r1]** —-&gt;  (*r1 = r0)</li></ul></blockquote></li><li><p><strong>基址变址寻址</strong>：将基地址寄存器 + 指令中给出的偏移量 = 数据存放的地址</p><blockquote><ul><li><p>前索引：</p><blockquote><ul><li>STR r0, [r1, #4] —-&gt; *(r1 + 4) = r0</li><li>LDR r0, [r1, #4] —-&gt; r0 = *(r1 + 4)</li></ul></blockquote></li><li><p>后索引:</p><blockquote><ul><li>STR r0, [r1], #4 —-&gt; *r1 = r0 ; <strong>r1 = r1 + 4</strong></li><li>LDR r0, [r1], #4 —-&gt; r0 = *r1; <strong>r1 = r1  + 4</strong></li></ul></blockquote></li><li><p>自动索引:</p><blockquote><ul><li><p>STR r0, [r1, #4] ! —-&gt; *(r1 + 4) = r0; <strong>r1 = r1 + 4</strong></p></li><li><p>LDR r0, [r1, #4] ! —-&gt; r0 = *(r1 + 4); <strong>r1 = r1 + 4</strong></p></li></ul></blockquote></li></ul></blockquote></li></ul><h3 id="多个数据访问"><a href="#多个数据访问" class="headerlink" title="多个数据访问"></a>多个数据访问</h3><ul><li><p>LDM ：读内存数据，加载到多个寄存器</p><blockquote><p><strong>LDM</strong> {条件}{s} &lt;MODE&gt; 基质寄存器 {!} , {Reglist}^</p></blockquote></li><li><p>STM：将多个寄存器的值，存储到一块内存</p><blockquote><p><strong>STM</strong> {条件}{s} &lt;MODE&gt; 基质寄存器 {!} , {Reglist}^</p></blockquote></li><li><p>MODE：</p><blockquote><ul><li>IA （increase after）— 后增加地址</li><li>IB （increase before）— 先增加地址</li><li>DA（decrease after）— 后减少地址</li><li>DB（decrease before）— 先减少地址</li></ul></blockquote></li><li><p>基址寄存器 ：存放内存的起始地址</p></li><li><p>！：最后更新基址寄存器的值</p></li><li><p>Reglist ：寄存器列表</p><blockquote><ul><li>多个寄存器从小到大，中间用“，”隔开{r0, r1, r2} 或 {r0, r7- r10}</li><li>寄存器编号大的 —- 内存高地址； 寄存器编号小的 —- 内存低地址</li></ul></blockquote></li><li><p>^ : 它存在：</p><blockquote><ul><li>Reglist 没有PC寄存器的时候，操作的寄存器是用户模式下的寄存器</li><li>在LDM指令中，有PC的时候，数据传输时，会将SPSR的值拷贝到CPSR，用于异常返回</li></ul></blockquote></li></ul><h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><ul><li><p>进（压）栈： <strong>stmfd sp!</strong> , {寄存器列表}</p></li><li><p>出栈：<strong>ldmfd sp!</strong> , {寄存器列表}</p></li><li><p>进行栈操作前<strong>，必须先设置sp的值</strong></p></li><li><p>进栈和出栈方式一样，<strong>ATPCS标准规定满减栈</strong></p></li><li><p>几种栈操作方式：</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/stack.jpg"></blockquote></li></ul><h2 id="CPSR-SPSR操作指令"><a href="#CPSR-SPSR操作指令" class="headerlink" title="CPSR/SPSR操作指令"></a>CPSR/SPSR操作指令</h2><ul><li><p>读操作：</p><blockquote><ul><li><p>MRS Rn, CPSR/SPSR</p><p>将状态寄存器的值，读到通用寄存器</p></li></ul></blockquote></li><li><p>写操作：</p><blockquote><ul><li><p>MSR CPSR/SPSR， Rn</p><p>将通用寄存器的值，写到状态寄存器</p></li></ul></blockquote></li></ul><h1 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h1><p>（instruction pipeline）—- 以三级流水线为例</p><ul><li>预取 （fetch）— <strong>PC寄存器工作在预取阶段</strong></li><li>译码 （decode）</li><li>执行 （execute）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/Instruction_pipeline.png"></p><h1 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h1><p>**链接地址:**编译器在编译程序的时候，指定的地址，指定这个地址的目的是期望程序在指定的链接地址执行</p><p>**运行地址:**程序实际在内存中的运行地址</p><p>伪指令：为了方便程序员使用，<strong>编译器设计的指令</strong>，该指令ARM核无法识别，需要编译器进行翻译</p><h2 id="常用的伪指令"><a href="#常用的伪指令" class="headerlink" title="常用的伪指令"></a>常用的伪指令</h2><ul><li><p>LDR r0, =0x999  —-&gt; LDR r0, [PC]</p></li><li><p><strong>LDR r0,</strong> **=Label **  —-&gt; LDR r0, [PC ,# 固定偏移量] </p><blockquote><p>读取Label标签表示的地址，存放到r0中，<strong>这个标签最终表示的地址受链接地址的影响</strong></p><blockquote><p>编译器：根据指定的代码开始地址，算出Label标签对应地址，存放在内存中，，通过内存访问指令，根据<strong>PC + 固定偏移量</strong>，读取内存值。换言之，<strong>代码编译结束时候，PC + 固定偏移量表示的内存地址中存放的数据就已经确定死了</strong></p></blockquote></blockquote></li><li><p>LDR r0,  Label  —-&gt; LDR r0, [PC, # 固定偏移量]</p><blockquote><p>读取Label标签表示的地址的内容</p></blockquote></li><li><p><strong>ADR r0, Label</strong> —&gt; <strong>根据当前PC的值 +/-偏移量，动态获取当前Label表示的内存地址</strong></p></li><li><p>问题：如何判别代码在实际内存中运行的地址？</p><blockquote><ul><li>ADR r0，_start 可以知道，因为它根据PC值，动态获取</li><li>LDR r0, =_start 无法知道，这条指令不论在哪运行，r0的值都是固定的（取决于指定的链接地址）</li></ul></blockquote></li></ul><h1 id="汇编与C混合编程"><a href="#汇编与C混合编程" class="headerlink" title="汇编与C混合编程"></a>汇编与C混合编程</h1><h2 id="汇编调用C语言"><a href="#汇编调用C语言" class="headerlink" title="汇编调用C语言"></a>汇编调用C语言</h2><ul><li><p>ATPCS：</p><blockquote><ul><li><p><strong>参数传递</strong>：函数参数传递的时候，<strong>前4个参数通过r0 - r3来传递，超过4个的参数通过栈传递</strong></p></li><li><p><strong>函数返回</strong>：函数返回值通过 r0 带回</p></li></ul></blockquote></li><li><p><strong>注意：！！！调用C语言之前，必须先设置SP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">mov r0, #3<br>mov r1, #5<br>ldr sp, =0x40001ff0 @!!! 必须设置sp<br>bl add //add是.c文件中的一个函数<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="C语言中内嵌汇编-—-GCC编译器为例"><a href="#C语言中内嵌汇编-—-GCC编译器为例" class="headerlink" title="C语言中内嵌汇编 — GCC编译器为例"></a>C语言中内嵌汇编 — GCC编译器为例</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> (<br><span class="hljs-string">&quot;指令1\n&quot;</span><br>    <span class="hljs-string">&quot;指令2\n&quot;</span><br>    ...<br>    :输出列表<br>    :输入列表<br>    :修改列表(通用的寄存器)<br>);<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">int</span> d;<br><br><span class="hljs-comment">//输出列表 --- 将寄存器值输出到C变量</span><br>:<span class="hljs-string">&quot;=r&quot;</span>(c), <span class="hljs-string">&quot;=r&quot;</span>(d)<br>    <br><span class="hljs-comment">//输入列表 ---- 将C变量输入到寄存器</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>:<span class="hljs-string">&quot;r&quot;</span>(a), <span class="hljs-string">&quot;r&quot;</span>(b)<br>    <br><span class="hljs-comment">//修改列表 ---- 在内联汇编的时候，发生修改的寄存器</span><br>:<span class="hljs-string">&quot;r0&quot;</span>, <span class="hljs-string">&quot;r1&quot;</span>, <span class="hljs-string">&quot;r2&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>C变量的引用， 从输出列表到输入列表开始编号：第一个C变量%0，第二个C变量 %1….</strong></p><h1 id="Volatile关键字-（重点）"><a href="#Volatile关键字-（重点）" class="headerlink" title="Volatile关键字 （重点）"></a>Volatile关键字 （重点）</h1><h2 id="gcc优化"><a href="#gcc优化" class="headerlink" title="gcc优化"></a>gcc优化</h2><h3 id="优化思想"><a href="#优化思想" class="headerlink" title="优化思想"></a>优化思想</h3><ul><li>如果之前已经把变量的对应的内存数据读到寄存器中，当需要再次读取该变量所对应的内存数据的时候，为了提高效率，编译器会直接使用上一次寄存器中的值，而不再重新从内存读值</li></ul><h3 id="优化级别"><a href="#优化级别" class="headerlink" title="优化级别"></a>优化级别</h3><ul><li>O1：一级优化</li><li>O2（speed）/Os（size）：二级优化</li><li>O3：三级优化</li></ul><h3 id="优化的问题"><a href="#优化的问题" class="headerlink" title="优化的问题"></a>优化的问题</h3><p>如果内存中的值，已经被其他的执行单元（比如其他线程、中断）进行了更改，而优化后的代码，每次从寄存器读值，就会造成寄存器中的值和内存中的值不一致的问题</p><h2 id="Volatile的作用"><a href="#Volatile的作用" class="headerlink" title="Volatile的作用"></a>Volatile的作用</h2><p>volatile修饰一个变量，<strong>防止编译器优化（本质）</strong>，告诉编译器每次使用该变量时，必须从变量所在的内存重新读值</p><ul><li><p>有中断处理函数的代码，使用了全局变量，需要注意什么问题？</p><blockquote><p>定义全局变量的时候，<strong>需要加volatile修饰</strong></p></blockquote></li></ul><h1 id="ARM-编程命令"><a href="#ARM-编程命令" class="headerlink" title="ARM 编程命令"></a>ARM 编程命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">arm-none-eabi-gcc -c .\start.s -o .\start.o  //只编译不链接<br>arm-none-eabi-gcc -c .\key_led.c -o .\key_led.o<br>arm-none-eabi-ld -Ttext=0x40000000 .\start.o .\key_led.o -o key_led.elf //链接，指定链接地址<br>arm-none-eabi-objcopy -O binary .\key_led.elf .\key_led.bin //格式转换，去除elf信息头<br></code></pre></div></td></tr></table></figure><h1 id="PWM定时器"><a href="#PWM定时器" class="headerlink" title="PWM定时器"></a>PWM定时器</h1><h2 id="PWM-脉冲宽度调制"><a href="#PWM-脉冲宽度调制" class="headerlink" title="PWM 脉冲宽度调制"></a>PWM 脉冲宽度调制</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/PWM Timer.png" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/pwm.gif" style="zoom:150%;" /><p>FS4412开发板中，PWM的时钟频率为 100MHz</p><p>三星的计数器是递减计数器</p><h1 id="串口通信接口"><a href="#串口通信接口" class="headerlink" title="串口通信接口"></a>串口通信接口</h1><h2 id="电平标准-—-外部的硬件电路决定"><a href="#电平标准-—-外部的硬件电路决定" class="headerlink" title="电平标准 — 外部的硬件电路决定"></a>电平标准 — 外部的硬件电路决定</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/RS232、RS485.png"  /><h2 id="RS232-和-RS485-（重点）"><a href="#RS232-和-RS485-（重点）" class="headerlink" title="RS232 和 RS485 （重点）"></a>RS232 和 RS485 （重点）</h2><p> <strong>RS232 vs RS485</strong></p><ul><li>RS232  三个线(RXD,TXD,GND), 全双工，交叉连接<br>RS485  三个线(A,B,GND),         半双工，A-A；B-B</li><li>RS485 传输距离更远</li><li>RS485 速度更快</li><li>RS485 抗干扰更好，RS485采用传输差分信号，A-B线电压差确定传输的一位数据</li><li>RS232 1: -(3<del>15v)  0: +(3</del>15)v  , RS485  1: +(2<del>6v)  0: -(2</del>6v)</li><li>RS485支持多点通信，RS232不支持</li></ul><h2 id="UART-—-芯片内部的异步收发器"><a href="#UART-—-芯片内部的异步收发器" class="headerlink" title="UART — 芯片内部的异步收发器"></a>UART — 芯片内部的异步收发器</h2><ul><li>UART— 芯片内部的串口通信标准的数据发送格式</li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/UART.png" style="zoom: 67%;" /><p>UART （Universal Asynchronous Receiver and Transmitter）—- 通用异步收发器</p><p>串口:数据是一位一位的发<br>并口:数据是多位一起发</p><ul><li><p>UART串口通信参数：</p><blockquote><ul><li>波特率 ：双方的通信速度</li><li>数据位：发送数据的位数 —- 先发送低位</li><li>停止位：表示收发停止</li><li>校验位：检查数据是否错误，奇偶校验（只能发现一位错误）</li><li>流量控制：需要硬件支持</li></ul></blockquote></li></ul><h3 id="串口通信数据错误："><a href="#串口通信数据错误：" class="headerlink" title="串口通信数据错误："></a>串口通信数据错误：</h3><ul><li>电平标准</li><li>波特率</li><li>数据位</li><li>停止位</li><li>校验位</li></ul><h3 id="系统三大总线"><a href="#系统三大总线" class="headerlink" title="系统三大总线"></a>系统三大总线</h3><p>数据、地址、控制</p><h3 id="DMA模式"><a href="#DMA模式" class="headerlink" title="DMA模式"></a>DMA模式</h3><p>Direct Memory Access：设备直接访问内存，不需要经过CPU</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul><li><p>异常处理流程</p><blockquote><p>​                                                                      <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/Expection Handling.png" style="zoom: 80%;" /></p></blockquote></li></ul><h2 id="ARM核硬件上自动做的事情"><a href="#ARM核硬件上自动做的事情" class="headerlink" title="ARM核硬件上自动做的事情"></a>ARM核硬件上自动做的事情</h2><ul><li><p>CPSR —-拷贝—-&gt; SPSR</p></li><li><p>设置CPSR对应位：</p><blockquote><ul><li>进入ARM态</li><li>进入对应的异常模式</li><li>禁止中断</li></ul></blockquote></li><li><p>保存PC的值到异常模式的 LR</p></li><li><p>将PC设置为异常向量表的对应位置：</p><blockquote><table><thead><tr><th>偏移量</th><th>异常</th></tr></thead><tbody><tr><td>0x1C</td><td>FIQ</td></tr><tr><td>0x18</td><td>IRQ</td></tr><tr><td>0x14</td><td>(Reserved)</td></tr><tr><td>0x10</td><td>Data Abort</td></tr><tr><td>0x0C</td><td>Prefetch Abort</td></tr><tr><td>0x08</td><td>Software Interrupt</td></tr><tr><td>0x04</td><td>Undefined Instruction</td></tr><tr><td>0x00</td><td>Reset</td></tr></tbody></table><p>&lt;Vector Table&gt;</p></blockquote></li><li><p>异常优先级、对应处理器模式、返回地址：</p><blockquote><table><thead><tr><th>优先级</th><th>异常</th><th>模式</th><th>返回地址</th></tr></thead><tbody><tr><td>1  最高</td><td>Reset</td><td>SVC</td><td>-</td></tr><tr><td>2</td><td>Data Abort</td><td>Abort</td><td>LR-8</td></tr><tr><td>3</td><td>FIQ</td><td>FIQ</td><td>LR-4</td></tr><tr><td>4</td><td>IRQ</td><td>IRQ</td><td>LR-4</td></tr><tr><td>5</td><td>Prefetch Abort</td><td>Abort</td><td>LR-4</td></tr><tr><td>6</td><td>Software Interrupt</td><td>SVC</td><td>LR</td></tr><tr><td>7   最低</td><td>Undefined Instruction</td><td>Undefined</td><td>LR</td></tr></tbody></table></blockquote></li></ul><h2 id="程序员需要做的事情"><a href="#程序员需要做的事情" class="headerlink" title="程序员需要做的事情"></a>程序员需要做的事情</h2><ul><li><p>设置异常向量表（在异常向量表中，写跳转指令，跳转指定异常处理函数）</p></li><li><p>告诉ARM核异常向量表的基地址</p><blockquote><ul><li>cortex-A系列以前，异常向量表可以存放在 0x0000，0000 （低地址）或 0xffff，0000（高地址）；cp15（协处理器）.c1（寄存器）决定异常向量表存放在高地址还是低地址</li><li>cortex-A系列以后，异常向量表可以在任意位置，cp15.c12保存异常向量表的基地址</li></ul></blockquote></li><li><p>编写异常处理函数：</p><blockquote><ul><li><p>设置SP寄存器</p></li><li><p>将通用寄存器R0~R12，进行压栈保护</p></li><li><p>异常处理</p></li><li><p>异常返回</p><blockquote><ul><li>恢复R0~R12 （出栈）</li><li>恢复CPSR</li><li>恢复PC</li></ul></blockquote></li></ul></blockquote></li></ul><h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><ul><li><p>CPU主要两种工作模式：轮询和中断</p><blockquote><ul><li>轮询：不断询问是否要处理事情，但很多时候不满足条件，浪费了CPU的时间</li><li>中断方式：当需要CPU处理的时候，产生一个信号，打断CPU正在做的事情，让CPU处理当前的事情，处理完后，回到打断之前的地方继续执行</li></ul></blockquote></li><li><p>中断处理注意点：</p><blockquote><ul><li>中断打断其他程序的执行，所以中断处理要尽可能的快，不能中断处理耗时过长</li><li>中断打断程序的执行，所以中断处理的时候，需要先保存现场（CPU的状态和CPU内部寄存器的值：压栈保存），中断处理结束，恢复现场</li></ul></blockquote></li></ul><h2 id="中断的五大概念（重点）"><a href="#中断的五大概念（重点）" class="headerlink" title="中断的五大概念（重点）"></a>中断的五大概念（重点）</h2><ul><li><p>中断源：产生中断的源头</p></li><li><p>中断号：SOC芯片厂家对SOC芯片内部<strong>中断源的编号</strong></p></li><li><p>中断处理函数：中断产生后，需要调用执行的函数</p></li><li><p>中断控制器：控制中断的优先级、中断是否被允许产生</p></li><li><p>内部中断和外部中断：</p><blockquote><ul><li><p>内部中断：SOC芯片内部控制器产生的中断</p></li><li><p>外部中断：SOC芯片外部管脚通过电平触发产生的中断</p><blockquote><p>高电平触发、低电平触发</p><p>上升沿触发、下降沿触发</p><p>双边触发</p></blockquote></li></ul></blockquote></li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/interrupt.png" style="zoom: 80%;" /><p>学习使用的FS4412开发板，是三星设计的SOC，一共有160个中断源</p><h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><ul><li><em><strong>中断处理过程</strong></em>：</li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/interrupt_handling.png" style="zoom: 60%;" /><ul><li><em><strong>MPCore 分布式中断控制系统</strong></em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/MPCore.png"></p><ul><li><em><strong>GIC：</strong></em> (Generic Interrupt Controller)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/GIC.png"></p><h1 id="A-D转换器"><a href="#A-D转换器" class="headerlink" title="A/D转换器"></a>A/D转换器</h1><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;exynos_4412.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;exynos_setup.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CLRINTADC = <span class="hljs-number">0x0</span>; <span class="hljs-comment">//INT_ADCn interrupt clear. Cleared if any value is written.</span><br><br>    <span class="hljs-keyword">int</span> data = ADCDAT &amp; <span class="hljs-number">0xfff</span>;<br>    <span class="hljs-keyword">int</span> v = (<span class="hljs-number">1800</span> * data) / <span class="hljs-number">0xfff</span>;<br><br>    uart_printf(<span class="hljs-string">&quot;%d : %d mv\r\n&quot;</span>, data, v);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   1.8v    0xfff</span><br><span class="hljs-comment">    x      data  </span><br><span class="hljs-comment"> */</span><br>    delay_time(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// A/D conversion starts by enable.</span><br>    ADCCON |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_interrupt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.init ADC</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    16bit 1: 12bit A/D conversion</span><br><span class="hljs-comment">    14bit 1: enable A/D converter prescaler</span><br><span class="hljs-comment">    6¬13bit 132: prescaler value data</span><br><span class="hljs-comment">    ADCMUX 0x3: Analog input channel select</span><br><span class="hljs-comment">    */</span><br>    ADCCON = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>) | (<span class="hljs-number">132</span> &lt;&lt; <span class="hljs-number">6</span>);<br>    ADCMUX = <span class="hljs-number">0x3</span>;<br>    <span class="hljs-comment">//2.init GIC</span><br>    request_irq(<span class="hljs-number">42</span>, adc_handler);<br>    <span class="hljs-comment">//3.init ARM</span><br>    enable_irq();<br>    <span class="hljs-comment">//4.init Combiner</span><br>    INTCOMBINER.IESR2 |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">19</span>);<br>    <span class="hljs-comment">//5.A/D conversion starts by enable.</span><br>    ADCCON |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_interrupt_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    adc_interrupt_init();<br><br>    <span class="hljs-comment">//do_something();</span><br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="IIC总线"><a href="#IIC总线" class="headerlink" title="IIC总线"></a>IIC总线</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>IIC（Inter-Integrated Circuit,又称 IIC）—- 由PHILIPS公司开发的<strong>串口总线，用于连接微控制器及其外围设备</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><ul><li>只有<strong>两条总线线路</strong>:一条串行数据线**(SDA),<strong>一条串行时钟线</strong>(SCL)** </li><li>每个连接到总线的器件都可以使用软件<strong>根据它的唯一的地址来识别</strong> </li><li>传输数据的设备间是简单的<strong>主/从关系</strong> </li><li>主机可以用作主机发送器或主机接收器 </li><li>它是一个真正的多主机总线，<strong>两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏</strong></li><li><strong>串行的8位双向数据传输</strong>，<strong>先发送高位</strong>，位速率在标准模式下可达100kbit/s,在快速模式下可达400kbit/s,在高速模式下可达3.4Mbit/s</li></ul></blockquote><h3 id="IIC总线信号类型"><a href="#IIC总线信号类型" class="headerlink" title="IIC总线信号类型"></a>IIC总线信号类型</h3><p>有3种类型信号：<strong>开始信号、结束信号、响应信号</strong></p><blockquote><ol><li>开始信号(S):SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据 </li><li>结束信号(P):SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据 </li><li>响应信号(ACK):接收器在接收到8位数据后，在第9个时钟周期，拉低 SDA 电平 </li></ol></blockquote><p><strong>注意:   SDA 上传输的数据必须在 SCL 为高电平期间保持稳定，SDA 上的数据只能在 SCL 为低电平期间变化</strong></p>  <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_Bus.png" alt="IIC signal" style="zoom: 67%;" /><h3 id="IIC-总线的数据传输格式"><a href="#IIC-总线的数据传输格式" class="headerlink" title="IIC 总线的数据传输格式"></a>IIC 总线的数据传输格式</h3><p>发送到 <strong>SDA 线上的每个字节必须是8位的，每次传输可以发送的字节数量不受限制。首先传输的是数据的最高位(MSB)</strong></p><p><strong>启动一个传输时，主机先发送 S 信号，然后发出8位数据。这8位数据中前7位为从机的地址，第8位表示传输的方向(0表示写操作，1表示读操作)。从机收到后会发出一个 ACK 信号</strong></p><p><em><strong>Read Sequence</strong></em> </p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_ReadSequence.png" style="zoom:80%;" /></blockquote><p><em><strong>Write Sequence</strong></em></p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_WriteSequence.png" style="zoom:80%;" /></blockquote><p><strong>I^2^C Terms</strong></p><table><thead><tr><th>Signal</th><th>Description</th></tr></thead><tbody><tr><td>S</td><td>Start Condition: SDA goes from high to low while SCL is high</td></tr><tr><td>AD</td><td>Slave I^2^C address</td></tr><tr><td>W</td><td>Write bit (0)</td></tr><tr><td>R</td><td>Read bit (1)</td></tr><tr><td>ACK</td><td>Acknowledge: SDA line is low while the SCL line is high at the 9 ^th^ clock cycle</td></tr><tr><td>NACK</td><td>Not-Acknowledge: SDA line stays high at the 9th clock cycle</td></tr><tr><td>RA</td><td>MPU-60X0 internal register address</td></tr><tr><td>DATA</td><td>Transmit or received data</td></tr><tr><td>P</td><td>Stop condition: SDA going from low to high while SCL is high</td></tr></tbody></table><p><strong>操作芯片的步骤：</strong></p><ul><li>通过原理图或手册，确定通信接口</li><li>确定是IIC或者是其他通信方式之后，找到从机地址（或者其他对应的地址信息）</li><li>查看手册确定寄存器操作方式（读写）</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>底层开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法笔记</title>
    <link href="/2021/Cpp-Note01/"/>
    <url>/2021/Cpp-Note01/</url>
    
    <content type="html"><![CDATA[<p>C++语法学习记录，做一个系统性梳理。</p><span id="more"></span><h1 id="C-学习路线"><a href="#C-学习路线" class="headerlink" title="C++学习路线"></a>C++学习路线</h1><h2 id="C-语言学习"><a href="#C-语言学习" class="headerlink" title="C++语言学习"></a>C++语言学习</h2><p>面向对象编程思想；<br>类的封装，构造和析构、静态成员、对象管理；<br>类的构造(有参构造函数、无参构造、拷贝构造、默认构造函数)和析构；<br>对象动态管理、友元函数、友元类、操作符重载；<br>C++编译器对象管理模型分析；<br>类对象的动态管理(new/delete)；<br>友元函数和友元类；<br>运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；<br>类的继承、多继承及其二义性、虚继承；<br>多态(概念、意义、原理剖析、多态案例)；<br>虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；<br>函数模板、类模板，模板的继承；<br>C++类型转换；<br>C++输入输出流(标准I/O文件I/O 字符流I/O)；<br>C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)</p><h2 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h2><ol><li>STL</li><li>设计模式</li><li>数据结构基础<br>顺序存储、链式存储、循环链表；<br>双向链表、栈(顺序和链式)、队列(顺序和链式)；<br>栈的应用、树基本概念及遍历、二叉树；<br>排序算法、并归算法、选择、插入、快速、希尔</li><li>UI界面开发</li><li>Unix/Linux网络服务器</li><li>数据库开发</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo@main/img/C++_StudyPath.png"></p><h1 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++基础语法"></a>C++基础语法</h1><h2 id="C-相对C语言的特性"><a href="#C-相对C语言的特性" class="headerlink" title="C++相对C语言的特性"></a>C++相对C语言的特性</h2><blockquote><ul><li>C语言：程序化开发语言，面向过程思想，适用于小规模问题的程序</li><li>C++：面向对象的编程思想，适用于大规模问题的合作开发</li></ul></blockquote><p>C++的加强部分：</p><blockquote><ul><li>命名空间</li><li>重载：函数重载、运算符重载</li><li>引用</li><li>面向对象：封装、继承、多态</li><li>泛型编程</li><li>异常处理</li><li>标准库STL</li></ul></blockquote><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>为了解决同一个作用域的符号名冲突，划分空间，区分同名</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> &lt;命名空间名字&gt; &#123;<br>    代码...<br>&#125;<br><br><span class="hljs-comment">/*局部引用*/</span><br>&lt;命名空间名字&gt;::&lt;函数名/变量名/类名&gt;<br><br><span class="hljs-comment">/*全局引用*/</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> &lt;命名空间的名字&gt; <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>:: ---- 作用域运算符<br></code></pre></div></td></tr></table></figure><ul><li>命名空间取别名 —- 一个命名空间可取多个别名，名字使用无区别</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> mySpace&#123;<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br><span class="hljs-keyword">namespace</span> mySpace2 = mySpace;<br></code></pre></div></td></tr></table></figure><ul><li>匿名命名空间 —- 定义自己命名空间不取名字，可直接使用里面内容，但仅当前文件有效</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-keyword">int</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; x &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-的输入和输出"><a href="#C-的输入和输出" class="headerlink" title="C++的输入和输出"></a>C++的输入和输出</h2><p><em><strong>C++ 中的输入输出通过流的方式来实现</strong></em></p><ul><li><p>流运算符 —- 做了函数重载</p><blockquote><p>输出：<code>&lt;&lt;</code></p><p>输入：<code>&gt;&gt;</code></p></blockquote></li><li><p>定义</p><blockquote><p>标准输入对象：<code>cout</code> </p><p>标准输入对象：<code>cin</code> —- 输入类型不匹配返回 <code>NULL</code>, 消除了连续输入多次字符产生垃圾字符的缺点</p><p>换行：<code>endl</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cout.<span class="hljs-built_in">width</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//设置域宽为5</span><br><br>cout &lt;&lt; oct &lt;&lt; <span class="hljs-number">5</span>; <span class="hljs-comment">//用八进制显示 </span><br><br><span class="hljs-comment">/*标志设置*/</span><br>oct <span class="hljs-comment">//八进制</span><br>hex <span class="hljs-comment">//十六进制</span><br>dec <span class="hljs-comment">//十进制</span><br>showbase <span class="hljs-comment">//显示前缀</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="C-的函数"><a href="#C-的函数" class="headerlink" title="C++的函数"></a>C++的函数</h2><h3 id="带默认参数的函数"><a href="#带默认参数的函数" class="headerlink" title="带默认参数的函数"></a>带默认参数的函数</h3><ul><li><p>存在默认值的函数，即使不传参也会按默认参数运行</p></li><li><p>可在函数声明或实现的时候添加默认值，但是不能同时添加，建议声明时加默认值</p></li><li><p>默认值可全部设置、可全部不设置，但<strong>部分默认值的时候，必须把默认值参数放参数列表后面</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">20</span>)</span> <span class="hljs-comment">//默认参数放后面</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="带占位参数的函数"><a href="#带占位参数的函数" class="headerlink" title="带占位参数的函数"></a>带占位参数的函数</h3><ul><li>为了方便以后扩展功能，预留的参数，解决C中不规范函数传参</li><li>占位参数不适用，函数定义时候，只写类型，不写变量名</li><li>可加默认值，调用函数必须传入占位参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sumNum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li><p>底层原理：<strong>编译器会将重载函数，设置为不同的函数名，根据参数类型顺序个数进行匹配</strong></p></li><li><p>提高了函数的易用性</p></li><li><p><strong>在同一作用域</strong>，一组函数名相同，参数列表不同的函数</p></li><li><p>重载通常是命名一组功能相似的函数，减少函数名的数量，提高程序的可读性</p></li><li><p>条件：</p><blockquote><ul><li><strong>函数名必须相同</strong></li><li><strong>参数列表必须不同（个数、类型、顺序）</strong></li><li><strong>函数的返回值不能单独作为构成重载的条件，可以相同，可以不同</strong></li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pritf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>const 关键字一般是不能构成重载的，但是const修饰的变量是引用时，可以构成重载</li><li>const 修饰类的成员函数时，可以和非const成员函数构成重载</li></ul><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><h3 id="原理、作用和使用规则"><a href="#原理、作用和使用规则" class="headerlink" title="原理、作用和使用规则"></a>原理、作用和使用规则</h3><ul><li><p>原理：引用的本质是，指针常量的使用：<code>int *const p</code></p></li><li><p>作用：</p><blockquote><ul><li>简化指针操作</li><li>引用给一个变量起了一个别名，对引用操作与对其绑定的变量或对象，操作一样</li></ul></blockquote></li><li><p>规则：</p><blockquote><ul><li><code>&lt;类型&gt; &amp;&lt;引用名&gt; = &lt;目标变量或对象名&gt;</code> —- <code>int &amp; a = b</code></li><li>引用声明必须初始化，初始化后不能改变引用空间的位置 —- <strong>必须绑定只能绑定一次</strong></li><li>引用的类型和目标变量或对象<strong>类型必须一致</strong></li><li>不能把已经有的引用名作为其他变量或对象的名字或别名</li><li><em>使用引用时，编译器底层生成指针，对其自动 * 运算</em></li></ul></blockquote></li></ul><h3 id="引用的用法"><a href="#引用的用法" class="headerlink" title="引用的用法"></a>引用的用法</h3><ul><li><p>函数传参 （主要）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> <span class="hljs-comment">//交换两个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>函数返回值 （返回变量须静态，函数可做左值）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">retFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> b = a + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> &amp;p = <span class="hljs-built_in">retFunc</span>(a);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-built_in">retFunc</span>(a) = <span class="hljs-number">80</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对数组引用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;p)[<span class="hljs-number">5</span>] = a;<br><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;<span class="hljs-built_in">func</span>())[<span class="hljs-number">5</span>]<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对指针引用 (几乎不用)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-keyword">int</span> *&amp;q = p;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="动态内存分配-—-new和delete"><a href="#动态内存分配-—-new和delete" class="headerlink" title="动态内存分配 —- new和delete"></a>动态内存分配 —- new和delete</h2><ul><li>new —- 申请内存并初始化对象</li><li>delete —- 释放内存并销毁对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>*p = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;*p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//防止野指针</span><br><span class="hljs-comment">//释放数组: delete []arr;</span><br></code></pre></div></td></tr></table></figure><table><thead><tr><th>C++动态内存管理—-new/delete</th><th>C语言动态内存管理—-malloc/free</th></tr></thead><tbody><tr><td>C++ 操作符</td><td>C/C++标准库函数</td></tr><tr><td>自己计算类型大小，返回对应类型指针</td><td>需要手动计算类型大小 返回void  *</td></tr><tr><td>调用构造函数和析构函数，初始化对象与销毁对象</td><td>只负责分配/释放空间</td></tr><tr><td>基于malloc/free实现的</td><td>/</td></tr></tbody></table><h1 id="C-面向对象之—-封装性"><a href="#C-面向对象之—-封装性" class="headerlink" title="C++面向对象之—-封装性"></a>C++面向对象之—-封装性</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ul><li><p>面向过程 (Procedure Oriented —- PO)</p><blockquote><p>解决问题时，面向过程会把事情拆分成，一个个函数和数据，按照顺序执行，完成任务</p></blockquote></li><li><p>面向对象 (Object Oriented —- OO)</p><blockquote><p>解决问题是，面向对象会把事情抽象成对象的概念。设计问题中的一个个对象，赋予他们属性和方法，让每个对象去执行自己的方法，解决问题</p></blockquote></li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ul><li><p>类 —- 某一具体事物的抽象，用于描述某一类事物的一种数据类型，包括属性和方法(函数)</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> </span><br><span class="hljs-class">&#123;</span><br>Access specifiers : <span class="hljs-comment">//访问权限 :访问修饰符</span><br> Data Members/variables;  <span class="hljs-comment">//数据成员</span><br> <span class="hljs-function">Member <span class="hljs-title">functions</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//成员函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculateArea</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br> <span class="hljs-keyword">int</span> x;<br> <span class="hljs-keyword">int</span> y;<br> <span class="hljs-keyword">int</span> r;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Circle::calculateArea</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * r * r;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote></li><li><p>对象 —- 某一类事物的个体，具体且唯一，创造后才会分配空间</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&lt;类名&gt;&lt;对象名&gt;; <span class="hljs-comment">// Circle circle;</span><br>&lt;类名&gt; *&lt;对象指针名&gt; = <span class="hljs-keyword">new</span> &lt;类名&gt;();<br>Circle * circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br><span class="hljs-keyword">delete</span> circle; <span class="hljs-comment">//记得删除，防止内存泄漏</span><br></code></pre></div></td></tr></table></figure></li><li><p>访问属性、成员函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*普通对象*/</span><br>Circle circle;<br>circle.r = <span class="hljs-number">10</span>;<br><span class="hljs-comment">/*对象指针*/</span><br>Circle *circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>circle-&gt;r = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">delete</span> circle;<br>circle = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="构造函数-—-不能定义为虚函数"><a href="#构造函数-—-不能定义为虚函数" class="headerlink" title="构造函数 —- 不能定义为虚函数"></a>构造函数 —- 不能定义为虚函数</h2><!--在构造对象时自动调用此函数，往往用来初始化对象内的成员变量--><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数名和类名相同，没有返回值类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>&#125;;<br>Circle::<span class="hljs-built_in">Circle</span>() <span class="hljs-comment">//构造函数</span><br>&#123;...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>当类中<strong>没有构造函数</strong>，编译器<strong>自动生成</strong>一个构造函数</p><p>当自己<strong>写了构造函数</strong>，编译器便<strong>不会默认生成</strong>构造函数了</p><h3 id="构造函数重载"><a href="#构造函数重载" class="headerlink" title="构造函数重载"></a>构造函数重载</h3><p>针对不同的初始化方式，可以对构造函数进行重载</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*Circle 类举例*/</span><br>Circle::<span class="hljs-built_in">Circle</span>(<span class="hljs-keyword">int</span> _r)<br>&#123;...&#125;<br>Circle::<span class="hljs-built_in">Circle</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y, <span class="hljs-keyword">int</span> _r)<br>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>作用：方便传参、提高性能（针对对象成员）、<strong>继承</strong>的时候在子类构造函数传父类成员参数</p><p><strong>只能在初始化列表的成员变量</strong>：</p><blockquote><ul><li><p>const 成员变量 — 被const修饰，已经成为常量，定义后不能被重新赋值</p></li><li><p>引用 — 引用定义同时必须初始化，且初始化后不能赋值</p></li><li><p>不含默认构造函数（默认参数）的类的对象</p><blockquote><p>使用初始化列表，不调用默认构造函数初始化，而是调用拷贝构造初始化</p><p>构造函数的函数体中只能赋值，不能初始化，因此没有默认构造函数的类的对象，只有在初始化列表初始化</p></blockquote></li><li><p>继承的时候，初始化父类</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y, <span class="hljs-keyword">int</span> _r);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> r;<br>&#125;;<br>Circle::<span class="hljs-built_in">Circle</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y, <span class="hljs-keyword">int</span> _r) : <span class="hljs-built_in">x</span>(_x),<br><span class="hljs-built_in">y</span>(_y),<br><span class="hljs-built_in">r</span>(_r)<br>        <br><span class="hljs-comment">/*继承时*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base <span class="hljs-comment">//假设Base有一个成员变量int x</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> y;<br>&#125;;<br>Derived::<span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y) : <span class="hljs-built_in">Base</span>(_x),<br><span class="hljs-built_in">y</span>(_y)<br>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li><p>调用拷贝构造函数的三种情形：</p><blockquote><ul><li><p>用一个对象初始化另一个同类对象的时候</p></li><li><p>用值传递的方式，给函数传对象参数的时候</p></li><li><p>用值传递的方式，让函数返回一个对象的时候</p><blockquote><p>C++标准允许一种（编译器）实现省略创建一个只是为了初始化另一个同类型对象的临时对象。指定这个参数（-fno-elide-constructors）将关闭这种优化</p><p>优化方式是建立一个对象引用绑定到返回的优化，可以省略两次调用拷贝构造函数</p></blockquote></li></ul></blockquote></li><li><p>深拷贝、浅拷贝</p><blockquote><ul><li>浅拷贝：默认拷贝为浅拷贝，针对指针对象，只拷贝指针存储的地址</li><li>深拷贝：针对指针对象，拷贝指针指向的空间</li></ul></blockquote></li></ul><p>如果只写了拷贝构造函数，默认构造函数也不分配了，这时不能正常创建对象，类中此时只有一个构造函数</p><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>explicit关键字只能用来修饰类的构造函数，且最好只修饰只有一个参数的构造函数</p><p>被修饰的构造函数不能发生相应的隐式类型转换，只能以显示的方式进行类型转换</p><ul><li><p>何时触发隐式拷贝构造函数？</p><blockquote><ul><li><p>一个对象作为函数参数，以值传递的方式传入函数体</p></li><li><p>一个对象作为函数返回值，以值传递的方式从函数返回</p></li><li><p>以A a = b的方式构造a，其中b也是A类型</p></li></ul></blockquote></li><li><p>所以在拷贝构造函数一般不会设计成禁止隐式转换</p></li></ul><h2 id="析构函数-—-最好定义为虚函数"><a href="#析构函数-—-最好定义为虚函数" class="headerlink" title="析构函数 —- 最好定义为虚函数"></a>析构函数 —- 最好定义为虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">~ <span class="hljs-built_in">Circle</span>(); <span class="hljs-comment">//函数名和类名相同，没有返回值类型，没有任何参数，前面加个~</span><br>在销毁对象时，自动调用此函数，往往用来释放对象内申请的资源<br></code></pre></div></td></tr></table></figure><ul><li>没有参数和返回值，但<strong>有this指针</strong></li><li>析构函数<strong>不能使用const</strong>修饰</li><li>一个类有且只有一个析构函数，所以<strong>不能重载</strong>，但可以有多个构造函数</li></ul><h2 id="static-静态-关键字-（重点）"><a href="#static-静态-关键字-（重点）" class="headerlink" title="static(静态)关键字 （重点）"></a>static(静态)关键字 （重点）</h2><p><code>static</code> 可以修饰成员变量与成员函数—— 静态成员访问 <code>&lt;类名&gt;::&lt;静态成员名&gt;</code></p><ul><li><p>什么时候使用 <code>static</code> 关键字</p><blockquote><ul><li>设计类的构造函数时候，传参冲突，无法区分类型相同的不同参数时候，不能构成构造函数重载，可以通过static 函数解决这个问题</li><li>一切不需要实例化（创建对象），就可以有确定行为的函数都应该设计为静态的</li></ul></blockquote></li><li><p>使用方法：</p><blockquote><ul><li><strong>静态成员变量一定要在类中定义，类外进行初始化</strong> ,如果是多文件编程，静态成员变量的初始化写在类的.cpp文件中，不要在头文件中对静态变量初始化</li></ul></blockquote></li></ul><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul><li><p>用于保存对象的地址，this指针是隐藏在<strong>非静态成员</strong>中的</p></li><li><p>this指针只和对象相关，<strong>静态成员是没有this指针的</strong></p></li><li><p>使用场景：</p><blockquote><ul><li>非静态函数中，返回对象本身 <code>rentrun this</code></li><li>非静态函数中，区分传入的形参名和对象内成员变量名 <code>this-&gt;x = x</code></li></ul></blockquote></li></ul><h2 id="const关键字-（重点）"><a href="#const关键字-（重点）" class="headerlink" title="const关键字 （重点）"></a>const关键字 （重点）</h2><p> const 修饰的成员变量，只能在初始化列表进行初始化，因为它已经是一个常量了，定义之后就不能赋值了</p><ol><li><p>可以定义const常量，具有不可变性。</p></li><li><p>便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。</p></li></ol><p>​        例如<code>void f(const int i)</code> 编译器就会知道i是一个常量，不允许修改；</p><ol start="3"><li><p>可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以    做到不变则已，一变都变！如（1）中，如果想修改Max的内容，只需要：const int Max=you want;即可！ </p></li><li><p>可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错； 例如： void f(const int i) </p></li><li><p>为函数重载提供了一个参考。 </p></li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span> ...... <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//一个函数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">//上一个函数的重载 ...... </span></span><br><span class="hljs-function">&#125;</span>; <br></code></pre></div></td></tr></table></figure><ol start="6"><li>可以节省空间，避免不必要的内存分配。</li></ol><blockquote><p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。 </p></blockquote><ol start="7"><li>提高了效率。 </li></ol><blockquote><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 </p></blockquote><h2 id="友元函数-—-friend"><a href="#友元函数-—-friend" class="headerlink" title="友元函数 —- friend"></a>友元函数 —- friend</h2><ul><li><p>友元函数不是类的成员函数，在类中声明，在类外定义</p></li><li><p>友元函数可以访问所有私有成员和保护成员，一般不会使用，这样会破坏面向对象的封装性</p></li><li><p>注意：</p><blockquote><ul><li>友元不具有相互性 — A是B的友元，不代表B是A的友元</li><li>友元不能被继承 — 父类的友元不一定是子类的友元</li><li>友元不具备传递性 — 你的朋友的朋友不一定是你的朋友</li></ul></blockquote></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul><li><p>运算符重载实际上对运算符赋予新的运算方式</p></li><li><p>目的是为了对象的运算操作简洁明了</p></li><li><p>规则：</p><blockquote><ul><li><p>大部分运算符可以重载，少数不行</p><blockquote><p>不能被重载的运算符：</p><ul><li><code>.</code> ：成员访问运算符</li><li><code>.*</code> , <code>-&gt;*</code> : 成员指针访问运算符</li><li><code>::</code> ：域运算符</li><li><code>sizeof</code> ：长度运算符</li><li><code>?:</code> ：条件运算符</li><li><code>#</code> ：预处理符号</li></ul></blockquote></li><li><p>重载运算符可以对运算符号做出新解释，但基本语义不变</p><blockquote><ul><li>无法改变运算符优先级</li><li>无法改变运算符结构特性</li><li>无法改变运算符所需的操作数</li><li>无法创造新的运算符</li></ul></blockquote></li></ul></blockquote></li><li><p>语法：</p><blockquote><ul><li>类的成员函数：<code>&lt;函数返回值&gt; operator &lt;运算符&gt; (&lt;形参表&gt;) &#123;&#125;</code></li><li>类的友元函数：<code>&lt;函数返回值&gt; operator &lt;运算符&gt; (&lt;形参表&gt;) &#123;&#125;</code></li></ul></blockquote></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="const与static的混淆点"><a href="#const与static的混淆点" class="headerlink" title="const与static的混淆点"></a>const与static的混淆点</h3><p>(1)const 的变量只能通过构造函数的初始化列表进行初始化；(貌似在c++11中可以正常编译)<br>(2)static 的变量只能通过在类外重新定义进行初始化；<br>(3)static const 变量 只能通过在类中直接用”=”进行赋值<br>(4) const成员函数可以修改静态成员变量<br>(5)const成员函数不能访问非const成员变量，不能调用非const成员函数<br>(6)一般来说const不能单独构成重载，但是const修饰的变量若是引用，则可以构成重载</p><h3 id="关于const的重载"><a href="#关于const的重载" class="headerlink" title="关于const的重载"></a>关于const的重载</h3><p>重载要求同一个作用域函数名相同，<strong>形参表的本质不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>上面两个函数构成重载，本质在于：非const函数隐藏的this指针指向是正常类型的对象，const函数的this指针，指向了const类型的对象</p><p>从形参本质上说，这两个函数的形参表已经不同了</p><p>基于此，<code>const int *a</code> 和 <code>int *a</code> 也能构成重载。传进去的指针一个指向常量，一个指向变量，形参表也不相同了。</p><p><code>const int &amp;a</code> 和 <code>int &amp;a</code> 也能构成重载，一个引用的是常量，一个引用的是变量</p><p><code>const int a</code> 和 <code>int a</code> <strong>不能构成重载</strong>，因为值传递，只是对形参赋值，和实参本体没有关系，加不加<code>const</code> 都没有分别</p><h3 id="六个默认的成员函数"><a href="#六个默认的成员函数" class="headerlink" title="六个默认的成员函数"></a>六个默认的成员函数</h3><p>构造函数、拷贝构造函数、析构函数、赋值运算符重载、&amp;运算符重载、const &amp;运算符重载</p><h1 id="C-面向对象之-—-继承性"><a href="#C-面向对象之-—-继承性" class="headerlink" title="C++面向对象之 —- 继承性"></a>C++面向对象之 —- 继承性</h1><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>  :</span> <span class="hljs-keyword">public</span> Based1,<span class="hljs-keyword">private</span> Based2...&#123;&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><ul><li>公有继承(public)：基类的<strong>公有成员</strong>也是派生类的<strong>公有成员</strong>，基类的<strong>保护成员</strong>也是派生类的<strong>保护成员</strong></li><li>保护继承(protected)：基类的<strong>保护和公有成员</strong>都是派生类的<strong>保护成员</strong></li><li>私有继承(private)：基类的<strong>公有和保护成员</strong>都是派生类的<strong>私有成员</strong></li></ul><h2 id="无法被继承的成员"><a href="#无法被继承的成员" class="headerlink" title="无法被继承的成员"></a>无法被继承的成员</h2><ul><li><p>基类的构造函数、拷贝构造函数、析构函数</p></li><li><p>基类的重载运算符</p></li><li><p>基类的友元函数</p></li><li><p>基类的私有成员</p></li></ul><h2 id="继承的函数隐藏-hiding"><a href="#继承的函数隐藏-hiding" class="headerlink" title="继承的函数隐藏 hiding"></a>继承的函数隐藏 hiding</h2><p><strong>派生类类和基类有同名函数，总是调用派生类的函数，基类函数被隐藏</strong></p><p><strong>派生类继承的函数不适合派生类或需要拓展，则需要重写基类的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;父类/基类&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在基类的基础上进行拓展</span><br>    Based::<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;子类/派生类&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="构造函数与析构函数的调用顺序"><a href="#构造函数与析构函数的调用顺序" class="headerlink" title="构造函数与析构函数的调用顺序"></a>构造函数与析构函数的调用顺序</h2><p>定义派生类的时候：</p><blockquote><p>1.调用基类构造函数 ： <strong>继承多个基类</strong>的时候，<strong>调用顺序按照继承顺序</strong> ，不是初始化顺序</p><p>2.成员对象的构造函数</p><p>3.派生类滋生的构造函数</p></blockquote><p>析构函数 调用顺序和构造函数相反</p><h2 id="多继承与多重继承"><a href="#多继承与多重继承" class="headerlink" title="多继承与多重继承"></a>多继承与多重继承</h2><p>多继承：一个派生类继承多个基类</p><p>多重继承：一个基类的派生类，继续派生</p><p>避免菱形继承问题，这是一个有缺陷的设计方案</p><blockquote><ul><li>数据冗余：菱形底部的类实例化，会调用两次顶部类的构造函数</li><li>二义性问题</li></ul></blockquote><!--菱形继承的解决方案，是把菱形顶部的类定义为虚基类--><h1 id="C-面向对象之-—-多态性"><a href="#C-面向对象之-—-多态性" class="headerlink" title="C++面向对象之 —- 多态性"></a>C++面向对象之 —- 多态性</h1><p>C++中，一般针对一个行为只会有一个名称，是对类的行为在抽象，主要作用在于统一行为的接口,提高方法的通用性</p><p>两种多态：</p><ul><li>静态多态：函数重载、泛型编程</li><li>动态多态：虚函数</li></ul><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>定义：</p><ul><li>动态绑定：运行时确定具体需要调用的函数</li><li>静态绑定：编译结束就确定了需要调用的函数</li></ul><p>作用：</p><ul><li>把不同的派生类对象都当作基类对象看待，屏蔽不同派生类对象的差异</li><li>提高程序的通用性适应需求的变化</li></ul><p>使用方法：基类的指针或引用指向子类的对象</p><h2 id="虚函数和动态多态"><a href="#虚函数和动态多态" class="headerlink" title="虚函数和动态多态"></a>虚函数和动态多态</h2><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>使用 <code>virtual</code> 关键字声明的函数，是动态多态实现的基础</li><li>非类的成员函数不能声明为虚函数</li><li>类的静态成员函数不能为虚函数</li><li><strong>构造函数不能定义为虚函数，析构函数最好定义为虚函数</strong></li><li>基类的某个成员声明为虚函数后，派生类的同名函数自动成为虚函数</li></ul><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>1.创建两个类，为继承关系</li><li>2.基类中函数声明为虚函数</li><li>3.派生类继承基类并重写基类虚函数</li><li>4.基类的 <strong>指针或引用</strong> 访问 <strong>基类或派生类对象</strong></li></ul><h2 id="覆盖（重写）、重载、隐藏"><a href="#覆盖（重写）、重载、隐藏" class="headerlink" title="覆盖（重写）、重载、隐藏"></a>覆盖（重写）、重载、隐藏</h2><ul><li><p>重写：派生类重新实现基类的虚函数</p><blockquote><p>不同作用域</p><p>函数名相同、参数相同、返回值相同</p><p>基类必须有虚函数</p><p>重写函数的权限限定符可以不同</p></blockquote></li><li><p>函数重载：同一个作用域参数不同的同名函数</p><blockquote><p>同一个作用域</p><p>函数名相同、参数不同、返回值可同可不同</p><p>可以不是虚函数</p></blockquote></li><li><p>隐藏：基类和派生类同名函数，总是调用子类的函数，隐藏父类函数</p><blockquote><p>不同作用域</p><p>函数名相同</p><p><strong>参数不同</strong>，<strong>无论有没有virtual</strong>关键字，基类函数都将隐藏</p><p><strong>参数相同</strong>，但基类<strong>没有virtual</strong>关键字，基类函数将被隐藏</p></blockquote></li></ul><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>建议将基类的析构函数设置为是虚函数，基类的析构函数声明为虚函数，则派生类的析构函数自动为虚函数</p><p><strong>当基类的指针指向派生类对象时，如果析构函数不是虚函数，则不会发生动态多态，而导致只会调用基类的析构函数，造成内存泄漏</strong></p><h2 id="虚函数原理和虚函数表"><a href="#虚函数原理和虚函数表" class="headerlink" title="虚函数原理和虚函数表"></a>虚函数原理和虚函数表</h2><h3 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h3><p>c++ 能够在运行时确定调用的函数,是因为引入了虚函数。一旦类中引入了 虚函数,在程序编译期间， 就会创建虚函数表,表中每一项数据都是 虚函数的入口地址</p><p>为了将对象与虚函数表关联起来,<strong>编译器会在对象中会增加一个指针成员用于存储虚函数表的位置</strong></p><p>基类的指针指向派生类对象时就是通过虚函数表的指针来找到实际应该调用的函数</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>基类与派生类都维护自己的虚函数表,如果派生类<strong>重写基类的虚函数</strong>,则虚函数表<strong>存储的是派生类的函数的地址</strong>,<strong>没有重写的虚函数则保存的是基类的虚函数表</strong></p><h2 id="抽象类和纯虚函数"><a href="#抽象类和纯虚函数" class="headerlink" title="抽象类和纯虚函数"></a>抽象类和纯虚函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>含纯虚函数的类，称为抽象类</li><li>纯虚函数：指定函数接口规范，而不做具体的实现，实现部分由继承它的子类去实现</li></ul><h3 id="特点和作用"><a href="#特点和作用" class="headerlink" title="特点和作用"></a>特点和作用</h3><ul><li>抽象类中只声明函数接口,<strong>不能有具体的实现</strong></li><li><strong>抽象类不能创建对象</strong>,<strong>可以定义指针与引用</strong></li><li>派生类继承基类,并且<strong>必须要实现基类中的所有纯虚函数</strong>,否则派生类也是抽象类</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>基类只知道派生类需要的方法，不知道具体实现</li><li>多个具有相同特征的派生类中抽象一个类出来，作为派生类的模板，防止子类设计的随意性</li></ul><h1 id="C-—-泛型编程"><a href="#C-—-泛型编程" class="headerlink" title="C++ —- 泛型编程"></a>C++ —- 泛型编程</h1><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><ul><li>不依赖具体的数据类型的程序</li><li>提高程序的通用性，<strong>将算法从数据结构中抽象出来，成为通用算法</strong></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>用不确定的类型参数产生一系列函数和类的机制</p></li><li><p>关键字：<code>template</code></p></li><li><p>工作方式：</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/Template.png" style="zoom:50%;" /></blockquote></li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, T2,T3...&gt; <span class="hljs-comment">//typename 可替换为 class</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>调用方式</strong>：—- 不允许隐式类型转换，调用类型必须严格匹配</p><blockquote><ul><li>自动类型推导 <code>func(a);</code></li><li>具体类型显示调用 <code>func&lt;int&gt;(a)</code> <strong>(推荐)</strong></li></ul></blockquote></li><li><p><strong>原理</strong>：函数模板中声明了参数类型T，表示了一种抽象类型，编译器检查到程序调用函数的时候，根据传递参数的实际类型生成模板函数</p></li><li><p><strong>和宏定义、函数对比</strong>：</p><blockquote><p>宏定义：</p><ul><li>优点：代码复用，适合所有的类型；</li><li>缺点：缺少类型检查，宏在预处理阶段被代替掉，编译器不知道宏的存在</li></ul><p>函数：</p><ul><li>优点：真正的函数调用，编译器对类型进行检查</li><li>缺点：类型不同时需要重复定义函数，代码无法复用</li></ul><p>模板函数：</p><ul><li>优点：代码复用，适合所有类型。克服普通函数弊端；编译器会进行类型检查。克服宏定义弊端</li><li>缺点：调试比较难，对程序员要求高；一般编写一个类型确定的函数，运行通过后，再修改成函数模板</li></ul></blockquote></li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><ul><li>对一批仅仅是成员数据类型不同的类的抽象</li><li>为一批类的家族，创建类模板，用以生成多种具体类</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassTemplate</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">void</span> ClassTemplate &lt;T&gt;::<span class="hljs-built_in">funcNumber</span>()<br>&#123;...&#125;<br><br><span class="hljs-function">ClassTemplate&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//类模板实例化必须显示给出具体数据类型</span><br></code></pre></div></td></tr></table></figure><ul><li><p><strong>原理</strong>：</p><blockquote><ul><li>类模板实例化：类模板—&gt;模板类</li><li>编译器自动用具体的数据类型替换类模板中的类型参数，生成模板类代码</li></ul></blockquote></li><li><p>二次编译机制：</p><blockquote><ul><li><p>编译时，编译器产生类的模板函数声明，实际确认类型后调用的时候，根据调用的类型，再次生成对应类型的函数声明和定义</p></li><li><p>二次编译机制，模板类中声明的友元函数，在类外实现时，找不到友元函数实现报错</p><blockquote><ul><li>类前置声明</li><li>友元模板函数的前置声明</li><li>友元模板函数增加泛型支持</li></ul></blockquote></li></ul></blockquote></li></ul><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>模板的声明和实现要放在一个文件里，否则编译时找不到定义</p><p>如果非要用多文件分开写，就在头文件里把实现的源文件包括进来</p><h1 id="C-—-STL"><a href="#C-—-STL" class="headerlink" title="C++ —- STL"></a>C++ —- STL</h1><ul><li>六大组件：<strong>容器(Container)、迭代器(Iterator)、算法(Algorithm)、</strong>仿函数(Functor)、适配器(Adaptor)、分配器(Allocator)</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li>容纳、包含一组元素或元素集合</li></ul><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p><strong>向量 — vector</strong>：本质是动态数组，尾端增删性能高</p><p>列表 — list：本质是双向循环链表，任何位置增删性能好，随机访问慢</p><p>双端队列 — deque：本质是动态数组，随机存取好，仅次于vector</p><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><ul><li>查找数据性能好</li></ul><p>集合(set)与多重集合(mulitiset)：set不允许重复，mulitiset允许数据重复</p><p><strong>映射(map)与多重映射(mulitimap):</strong></p><blockquote><ul><li>键值对容器，数据成对出现，第一个值为key，第二个字为value，key只能在map出现一次，mulitimap允许key重复</li></ul></blockquote><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>检查容器内元素并遍历元素的数据类型</li><li>C++趋向用迭代器而不是下标</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客成长记</title>
    <link href="/2021/blog-building/"/>
    <url>/2021/blog-building/</url>
    
    <content type="html"><![CDATA[<p>总结一下博客搭建的整个过程中，每个功能的实现，都用到了哪些工具。对博客搭建的过程做个回顾，也是为了以后自己想要再使用这些工具的时候方便寻找。</p><span id="more"></span><h1 id="博客框架"><a href="#博客框架" class="headerlink" title="博客框架"></a>博客框架</h1><h2 id="动态博客"><a href="#动态博客" class="headerlink" title="动态博客"></a><del>动态博客</del></h2><p>综合考虑之后，放弃了动态博客搭建。主要精力折腾服务器和数据库，等工作啥稳定说不定会试试。或许忙起来更不想折腾了，唉。<br>看过一些框架：<a href="https://wordpress.org/"><strong>WordPress</strong></a> 、<a href="http://typecho.org/"><strong>Typecho</strong></a> 等</p><h2 id="静态博客"><a href="#静态博客" class="headerlink" title="静态博客"></a>静态博客</h2><p>了解过的：<a href="https://gohugo.io/"><strong>Hugo</strong></a>;    <a href="https://vuepress.vuejs.org/zh/"><strong>VuePress</strong></a>;<br>使用过的：<br><a href="https://gridea.dev/"><strong>Gridea</strong></a>;<br>使用过的第一款静态博客框架，方便快捷，一个客户端全搞定，不要Git等环境支持。<br>但是，成也萧何败也萧何，它的客户端同步太不稳定了，经常失败。最后，我还是自己手动Git push到远程仓库。<br>好处在于不需要关注其他，专心在博客写作上。<br><a href="https://hexo.io/zh-cn/"><strong>Hexo</strong></a>;</p><h1 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h1><p>写作主要用Markdown，使用的两款编辑器：<br>主力 <a href="https://typora.io/"><strong>Typora</strong></a>;备用<a href="https://code.visualstudio.com/"><strong>vsCode</strong></a>;<br>写博客主要用的Typora，vsCode也能写Markdown，但只要用来写代码。</p><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="图床管理工具："><a href="#图床管理工具：" class="headerlink" title="图床管理工具："></a>图床管理工具：</h2><p><a href="https://molunerfinn.com/PicGo/"><strong>PicGo</strong></a>; 网上推荐的比较多，支持主流的图床，使用体验还可以。</p><h2 id="图床："><a href="#图床：" class="headerlink" title="图床："></a>图床：</h2><p>图床选择太多了，我发图不多，懒得折腾了，反正有现成GitHub账号就用仓库但图床了。<br>但是，这种用法确实不太好，背离了GitHub的初衷，如果仓库塞太多图片是会被警告的。</p><h3 id="对象存储服务做图床"><a href="#对象存储服务做图床" class="headerlink" title="对象存储服务做图床:"></a><del>对象存储服务做图床</del>:</h3><p>存的不多，不想花钱（了解了一下,当图床用的话没多少钱）和费事。<br>Amazon s3、Google storage；<br>七牛云、又拍云、腾讯云、阿里云、华为云都可以选</p><h3 id="静态资源托管平台做图床："><a href="#静态资源托管平台做图床：" class="headerlink" title="静态资源托管平台做图床："></a>静态资源托管平台做图床：</h3><p><del><a href="https://gitee.com/"><strong>Gitee</strong></a></del>；<br>据说图片<strong>超过1M访问要登录账号</strong>，虽然我图片很少有1M以上的，但是放弃。<br><a href="https://github.com/"><strong>GitHub</strong></a>;<br>邮箱注册，方便快捷，没有乱七八糟的认证。服务器在国外，访问较慢。可以使用cdn缓存来解决访问慢的问题。</p><h3 id="第三方图床"><a href="#第三方图床" class="headerlink" title="第三方图床"></a><del>第三方图床</del></h3><p>sm.ms；imgchr（路过图床）；聚合图床等。</p><h3 id="社交网站图床"><a href="#社交网站图床" class="headerlink" title="社交网站图床"></a><del>社交网站图床</del></h3><p><del>微博图床</del>（没法用了，官方被嫖太多了，限制外链了）、qq空间等。</p><h3 id="自建图床"><a href="#自建图床" class="headerlink" title="自建图床"></a>自建图床</h3><p>有条件的时候尝试一下自己搭个图床，自己做的东西才是最放心，不用担心跑路。</p><h1 id="博客发布"><a href="#博客发布" class="headerlink" title="博客发布"></a>博客发布</h1><p><strong>GitHub Pages</strong><br>GitHub提供页面化服务，可以把托管的静态资源渲染成网页。（使用Pages服务的仓库名称特定，一个账号限制一个）其实，这个服务的初衷是帮助用户，直观的展示自己的项目结构，毕竟看文件夹和代码太不直观了。用于博客建站也算是个邪用，发发文字为主的内容应该问题不大，要是白嫖服务器太狠也对网站发展不好，希望好的平台能有好发展吧。</p><p><del><strong>Gitee Pages</strong></del><br>使用该服务要身份证实名认证，这我理解，网络治理监管需要嘛，谁知道会不会有人用这个服务发布不良信息呢。但是要求<strong>手持身份证，人脸和身份证都要拍</strong>，实在太膈应我了，哪怕你能够支付宝、微信啥的快捷认证我都用了。而且除了服务器在国内访问快些，其他方面真的难用，不仅是Pages服务。</p><p>还有一些其他的托管平台或提供页面发布的方式，可以自行寻找。</p><h1 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><strong>Hexo主题——Fluid</strong><br>功能丰富，插件多，简洁好看，我很喜欢。<br><strong>Gridea主题——Breek</strong><br>当初看到这个主题，也很喜欢它排版和样式，可惜没有分类和侧边目录。</p><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p><del><strong>gittalk</strong></del><br>基于GitHub issue，需要登录GitHub账号才能评论，而且申请权限太多了，所有公共仓库的读写权限。<br><strong>valine评论</strong><br>基于LeadCloud，轻量的评论系统，用的人也多，有了问题也好问。</p><h2 id="看板娘喵"><a href="#看板娘喵" class="headerlink" title="看板娘喵"></a>看板<del>娘</del>喵</h2><p>参考：<br><a href="https://www.xifenghhh.top/article/hexo-fluid-theme-beautification-with-live2d-kanban-girl/">Hexo Fluid主题美化之添加Live2D看板娘</a> </p><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a></p><h2 id="封面制作"><a href="#封面制作" class="headerlink" title="封面制作"></a>封面制作</h2><p><a href="https://colorfu.art/editor"><strong>colorfu</strong></a><br>一个很好用的在线背景图制作网站</p>]]></content>
    
    
    <categories>
      
      <category>博客志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2021/hello-hexo/"/>
    <url>/2021/hello-hexo/</url>
    
    <content type="html"><![CDATA[<p>今年初萌生了写个人博客的想法，在看到网络上一篇篇优秀的博文之后，受到吸引，便想着自己也搭建一个属于自己博客。在了解了一些搭建博客的相关知识之后，我选择了用Hexo框架进行写作。</p><span id="more"></span><h1 id="为什么想要搭建个人博客"><a href="#为什么想要搭建个人博客" class="headerlink" title="为什么想要搭建个人博客"></a>为什么想要搭建个人博客</h1><p>正如开篇所说，想要写博客最初是受到了其他优秀博客的吸引，想要自己拥有一个个人博客，也有“这样很酷”、“学编程就应该写博客”这样的想法在。此外，我认为写博客也能够很好的帮助我，梳理学习过程中的思路，为知识做系统性的总结和归纳。很多时候，好像明白了一个知识点，但下笔记录，系统梳理的时候总是能发现很多的不足，这时候我才意识到，自己原来知识“似懂非懂”。</p><p>同样是记录学习过程，整理自己的知识体系，笔记也能够承担相应的职能，为什么非要写博客呢？对此我看到过很多的观点，有人觉得博客搭建之后更加直观，笔记查看不如博客来的方便，有人认为博客更便于分享等等。这些都是促使我选择博客的原因之一，但最重要的是，写博客带给我一种“仪式感”。我花费了时间精力，学习怎么搭建博客，排除了过程中的种种问题，最后搭建了一个博客，自然不会轻易的将它荒废掉。或许这就是，“不是轻易得到的，往往更加珍惜吧”。</p><p>确定了写博客的目标，那么在哪写博客呢？像是CSND、博客园、简书等都是很经典的博客写作平台，我在查资料的时候，经常从这些平台搜寻相关博文，它们也帮助我解答了许多学习遇到的困难。但，它们有着界面不简洁，有强制广告区等问题。这也无可厚非，毕竟是需要盈利的平台。但出于个人书写的需要，我希望除了自己的文章和笔记之外，没有广告推广之类的干扰。那么搭建一个个人博客，就是一个不错的选择。</p><h2 id="为什么选Hexo"><a href="#为什么选Hexo" class="headerlink" title="为什么选Hexo"></a>为什么选Hexo</h2><p>在看过一些网上搭建博客的教学文章和视频后，在动态博客和静态博客两大类中，我选择了后者。理由很简单，动态博客需要服务器支持，要维护数据库，虽然添加功能要比静态博客方便，但对于单纯写作来说，动态博客搭建太麻烦了，我也不是要搭建一个博客交流社区。每年维护服务器什么的也是一笔开支，目前没有富裕的条件去维持。静态博客搭建更加简单快捷，现有的静态博客框架非常多，部署简单，虽然不能像动态博客那样后台管理，但也不容易出问题，更安全。都是静态文件，要是有问题实在找不出来，直接干掉文件夹重来就好了（懒人一个）。</p><p>在许多的静态博客框架中，我选择了Hexo。Hexo用的人很多，遇到问题我可以很快的找到解答，许多问题大家都遇到过。其次，Hexo支持的插件和拓展丰富，还有相比其他静态框架，据说渲染速度还是很优秀的。hugo的速度公认最快，很多博主也说把自己的博客迁移到Hugo上了，我了解之后还是选择了用Hexo，渲染慢一点我也能接受，主要hugo偏后端一些，基于Go语言，我不会Go啊。Hexo对html标签比较友好，我了解一些，在一些小地方还能改改。虽说Hexo速度不及Hugo，但据一些Hexo重度用户说，除非写了上千篇文章，还不至于渲染慢的受不了。正好电脑上，也有Node.js的环境，就Hexo完事了。还有就是我很喜欢，Fulid这个Hexo主题，Hexo还有中文社区，查看文档也更方便。（还是要好好提高英文水平）</p><p>算了，与其纠结框架选择，不如好好写内容，别人Hexo搭建的博客也用的蛮好。</p><h2 id="Gridea使用感受"><a href="#Gridea使用感受" class="headerlink" title="Gridea使用感受"></a>Gridea使用感受</h2><p>PS：在此之前，我用过Gridea，也是一个静态博客写作工具。它简直是懒人福音，不同于Hexo需要命令行操作和git环境，Gridea几乎所有写作都可以在客户端完成，可以自定义主题。配置好仓库后，本地渲染预览之后，点击同步直接推送到GitHub（或者其他托管平台）上，简洁方便。但是，它的同步实在是太容易出错了，经常推送数次都失败，最后我还是只有手动“git push”。此外，用的人比较少（我感觉的），使用过程出现很多问题，我都找不到解答，网上很多只有搭建教程，就只说了怎么搭建。主题也比较少，我浏览了官方网站的所有主题，没有支持文章分类的主题，也可能是Gridea本身就没开发分类这个功能。这对我来说太难受了，文章查找起来很混乱。表签代替分类，也不是不行，但是标签本来就是标注文章涉及了哪些个方面，把标签当分类就不能打多个标签，而且也不能多级分类。</p><p>在使用了一段时间的Gridea之后，我决定换一个框架了。之前写的博客，保留在原来仓库，正好借换框架，新建一个博客把内容细化，之前的博客就用来记录生活和个人兴趣相关的内容。新博客针对性的写学习笔记。之前那个Gridea的Breek主题，我也蛮喜欢的，我一开始折腾了好久，把主题源码都看了一遍，改了不少自己想要的细节。可惜没有文章分类和侧边目录，一旦文章比较长，看起来就很费劲。</p><h1 id="搭建过程踩坑记录"><a href="#搭建过程踩坑记录" class="headerlink" title="搭建过程踩坑记录"></a>搭建过程踩坑记录</h1><h2 id="部署hexo博客"><a href="#部署hexo博客" class="headerlink" title="部署hexo博客"></a>部署hexo博客</h2><p>静态博客搭建，主要有这么几个部分：静态博客框架、托管平台、域名（可选）、第三方拓展（可选）<br>我选择的Hexo框架，托管平台为GitHub，使用GitHub Pages服务把我的静态资源渲染成页面。这种方式搭建博客，步骤如下：</p><h3 id="1-Node-js-下载安装"><a href="#1-Node-js-下载安装" class="headerlink" title="1.Node.js 下载安装"></a>1.Node.js 下载安装</h3><p><a href="https://nodejs.org/en/download/">Node.js下载地址</a><br><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">安装教程</a><br>Hexo框架是基于Node.js的，没有对应环境无法运行。下载安装Node.js，基本没什么问题，对着安装步骤，一路默认安装就好了，就是注意如果是Windows，不要把它装到C盘，除非你C盘真的大不在乎被软件塞。安装好之后，打开命令行输入 <code>node -v</code>，查看是node否安装正确（有版本号说明对了），再输入<code>npm -v</code>查看包管理器是否安装正确。这两个命令是Hexo运行必须的。<br><code>v14.15.3</code> node.js版本<br><code>6.14.9</code> npm版本<br>安装时，尽量非测试版本的最新版。</p><h3 id="2-git-下载安装"><a href="#2-git-下载安装" class="headerlink" title="2.git 下载安装"></a>2.git 下载安装</h3><p><a href="http://git-scm.com/downloads">git下载地址</a><br><a href="https://www.runoob.com/git/git-install-setup.html">git下载教程</a><br>同样安装好之后，检查版本号。命令行输入 <code>git --version</code> 得到版本信息<br><code>git version 2.23.0.windows.1</code></p><h3 id="3-本地搭建hexo博客"><a href="#3-本地搭建hexo博客" class="headerlink" title="3.本地搭建hexo博客"></a>3.本地搭建hexo博客</h3><p><a href="https://hexo.io/zh-cn/">Hexo中文版网址</a><br><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><h4 id="1-下载Hexo客户端"><a href="#1-下载Hexo客户端" class="headerlink" title="1)下载Hexo客户端"></a><strong>1)下载Hexo客户端</strong></h4><p><code>npm install hexo-cli -g</code><br>该命令中的 -g 参数表示全局安装，也可以选择安装到指定文件夹，在将hexo命令添加到环境变量。但明显全局安装不易出错。如果不再使用需要卸载Hexo，在命令行输入<br><code>npm uninstall hexo-cli -g</code><br>如果由于网络不畅导致安装失败，重新输入下载命令进行安装即可。实在太慢，就安装一个淘宝的镜像源，命令行输入<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>之后下载操作把<code>npm</code>改成<code>cnpm</code></p><h4 id="2-检查hexo命令"><a href="#2-检查hexo命令" class="headerlink" title="2)检查hexo命令"></a><strong>2)检查hexo命令</strong></h4><p>命令行输入<code>hexo -v</code>检查版本号</p><h4 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="3)初始化hexo"></a><strong>3)初始化hexo</strong></h4><p>选择一个文件夹，在此处进入命令行，输入<br><code>hexo init XXX</code><br>XXX 是博客文件夹名称，该命令会创建一个名为’XXX’的文件夹，里面是Hexo博客的源文件。以后一旦出现任何问题，如果实在无法解决，直接把该文件夹干掉重来就好，不过记住之前把自己的文章备份好。</p><p><strong>踩坑</strong>：windows下，在命令行创建文件夹<code>mkdir XXX</code>，进入之后，执行<code>hexo init</code>。或者 直接<code>hexo init XXX</code>。在图形界面用鼠标创建XXX文件夹，进入执行<code>hexo init</code>，总是初始化失败，不知道为啥。</p><h4 id="4-渲染文件启动hexo"><a href="#4-渲染文件启动hexo" class="headerlink" title="4)渲染文件启动hexo"></a><strong>4)渲染文件启动hexo</strong></h4><p>输入<br><code>hexo g</code> 渲染静态网页<br>渲染完成后，输入<br><code>hexo s</code>  启动hexo本地服务器<br>成功启动后，打开本地4000端口查看生成的博客网页</p><p>到此hexo本地搭建完成，如何生成新文章，更换主题，先不管。相关操作，参考官方文档。</p><h3 id="4-部署hexo博客到GitHub"><a href="#4-部署hexo博客到GitHub" class="headerlink" title="4.部署hexo博客到GitHub"></a>4.部署hexo博客到GitHub</h3><p>注册GitHub账号 —&gt; 新建仓库（仓库必须名为：用户名.github.io）—&gt; 初始化仓库 —&gt;启动GitHub Pages服务<br>完成之后，GitHub会分配一个<code>用户名.github.io</code>的域名给你</p><p>这个过程简单，网上参考流程很多。</p><p>在完成GitHub Pages服务启动之后，回到博客目录下，安装hexo自动部署工具。<br>输入<code>npm install hexo-deployer-git --save</code><br>安装完成后，修改博客目录下的，<code>_config.yml</code> 文件<br>打开文件，找到deploy，修改下面的字段：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">tpye:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/用户名/仓库名.git</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></div></td></tr></table></figure><p>类型改为git，repo是仓库地址，branch为分支<br>注意冒号为英文冒号，冒号后有空格。</p><p>完成之后，回到博客目录，输入<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code><br>清理之前的渲染文件，重现渲染 推送到远程仓库，第一次推送会要求输入GitHub用户名和密码<br>推送完成成功部署到GitHub仓库，在浏览器输入<code>用户名.github.io</code>（之前的域名），就能看到生成的博客网页了。</p><p><strong>踩坑</strong><br>修改hexo配置文件”_config.yml” 中仓库地址，我 使用https地址总是报错<br><code>fatal: unable to access &#39;https://github.com/xxx/xxx.github.io/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</code><br>按照网上解决方案，改用ssh地址：<br><code>git@github.com:xxx/xxx.github.io.git</code><br>但是依旧报错，我检查之后报错信息后，发现是和我另一个git账号的ssh信息冲突了。我之前保存了另一个GitHub账号的ssh密钥在电脑上。<br>解决方案，删除已有的ssh密钥，重新为两个账号配置ssh密钥。<br>参考博文<a href="https://blog.csdn.net/u010132177/article/details/104825446">同一台电脑怎样配置并使用多个git账号</a><br>最后推送成功到GitHub上</p><h3 id="5-hexo常用命令"><a href="#5-hexo常用命令" class="headerlink" title="5.hexo常用命令"></a>5.hexo常用命令</h3><p><code>hexo cl</code>清除上次渲染的文件<br><code>hexo g</code> 渲染页面<br><code>hexo s</code>启动本地hexo<br><code>hexo d</code> 推送到远程仓库</p><p><code>hexo new  xxx</code> 新建文章<br><code>hexo new page xxx</code> 新建页面</p><h2 id="优化hexo博客"><a href="#优化hexo博客" class="headerlink" title="优化hexo博客"></a>优化hexo博客</h2><h3 id="1-主题更换"><a href="#1-主题更换" class="headerlink" title="1.主题更换"></a>1.主题更换</h3><p>首先，去hexo官网的主题页面挑选一个喜欢的主题，在主题的GitHub仓库下载主题文件夹压缩包，解压之后，将主题文件夹，放到博客根目录的“themes”文件夹下。</p><p>然后，修改”_config.yml”中的”theme”字段，把主题名称更换为，刚刚下载的主题文件夹的名字。比如：<br><code>theme: fluid</code><br>之后保存文件，重新渲染页面，启动hexo，就能看到主题已经被更换了。</p><p>每个主题的自定义设置不同，具体看主题仓库的说明文件，修改对应代码，把主题改成自己想要的样子。</p><h3 id="2-Front-Matter"><a href="#2-Front-Matter" class="headerlink" title="2.Front Matter"></a>2.Front Matter</h3><p>文章的Front Matter，指定个别文件的变量，比如发布日期，标题，更新日期，分类和标签等，具体的属性设置参考官方说明：<br><a href="https://hexo.io/zh-cn/docs/front-matter">Front Matter</a></p><p>常用的一些参数：</p><p><code>title: xxx</code>    文章标题<br><code>index_img: url</code>    文章缩略图，url为图片地址<br><code>banner_img: url</code>    文章头图，url为图片地址<br><code>date:xx/xx/xx xx:xx:xx</code>  文章发布日期<br><code>author: xxx</code>    作者<br><code>categories: xxx</code>    分类/多个分类用 - 相隔<br><code>tags: xx</code>    标签/多个标签用 - 相隔</p><p>关于分类：Hexo默认没有同级分类</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-string">-sport</span><br><span class="hljs-string">-ball</span><br></code></pre></div></td></tr></table></figure><p>这样，ball类会被认为是sport的子类</p><p>如果需要同级分类用英文方括号把分类名括起来</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-string">-[sport,ball]</span><br><span class="hljs-string">-[art]</span><br></code></pre></div></td></tr></table></figure><p>这样，sport 和 art同级，ball是sport的子类</p><h3 id="3-添加about页面"><a href="#3-添加about页面" class="headerlink" title="3.添加about页面"></a>3.添加about页面</h3><p>特别注意的是，layout，该属性指定了文章的布局。默认的博客结构中是没有”about”页面的，但许多主题都会自带”about”页面，博客也通常有一个”about”页面来说明博客和作者的一些基本信息。</p><p>在博客根目录打开命令行（可以用Git Bash），输入<code>hexo new page about</code> 新建一个about页面<br>在博客根目录的source文件夹中就会出现一个about文件夹，里面有一个index.md文件，在文件的Front Matter部分添加，layout: about 以此指定布局为”about page”，如果不指定，主题会默认这是自定义页面布局”custom page”。<br>再在，主题文件夹的”_config.yml”中启用about页面。（每个主题配置方法有所不同）</p><h3 id="4-自定义域名"><a href="#4-自定义域名" class="headerlink" title="4.自定义域名"></a>4.自定义域名</h3><p>首先从域名提供商那购买一个域名，我是从阿里云买的域名，拥有域名之后，设置域名解析。在解析类型那选择 CNAME类型，这种类型是把购买的域名解析到另一个域名，正是我们需要的，因为我们已经有了GitHub Pages提供的 XXX.github.io域名了。把域名解析到 GitHub分配的域名。</p><p>登录GitHub账号，在Pages的Custom site中填入刚刚完成解析的域名，点击save保存。<br>这时，仓库中多了一个“CNAME”文件，里面写的就是自定义的域名。<br>回到hexo博客根目录，打开source文件夹，新建一个文本文件，把自定义域名写入，保存。修改文件名为“CNAME”，注意没有后缀名，就叫CNAME。<br>回到博客根目录，修改_config.yml文件，在skip_render: 后面写上CNAME，注意冒号后有空格<br>skip_reder: 后面指定的文件，在渲染时会被跳过，这样一来，CNAME文件就不会在渲染时被修改。</p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>图床选择参考：<br><a href="https://blog.cyfan.top/p/eb490c73.html">图床的千层套路</a> by: 陈YFの博客<br>ps: 我在寻找博客框架时，正好看到了该文作者的博客，使用的正是Hexo的Fluid主题，我才决定用Hexo的，看到的瞬间就喜欢上了。</p><p>Fluid主题优化参考：</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">Fluid主题 添加评论</a></p><p><a href="https://hexo.fluid-dev.com/posts/fluid-footer-custom/">Fluid 页脚增加网站运行时长</a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>博客框架看了五六个，实际上手了两个框架，配置主题，修改主题，推送GitHub，自定义域名，修改样式，配置评论插件等等，折腾了一大圈，猛然觉察自己似乎偏离了搭博客的初心。其实纠结于用什么主题、什么框架并不重要，只要它能用，够用，不会随随便便出问题就行了，最主要是坚持写博客的毅力，持之以恒去写作。无论框架多么高级，界面多么优美，失去了内容的支撑，也不过是华而不实的空壳子。</p><p>希望自己，坚持写作，用内容装点这费了些力气才搭建起的博客。</p>]]></content>
    
    
    <categories>
      
      <category>博客志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arduino+ESP8266的远程控制小车</title>
    <link href="/2021/Arduino-ESP8266-Car/"/>
    <url>/2021/Arduino-ESP8266-Car/</url>
    
    <content type="html"><![CDATA[<p>简单介绍如何利用Arduino单片和ESP8266开发板，结合物联网云平台，制作一款能远程遥控的小车。<br>KeyWords：单片机控制、WiFi、远程遥控、手机App</p><span id="more"></span><h1 id="Arduino-ESP8266的远程控制小车"><a href="#Arduino-ESP8266的远程控制小车" class="headerlink" title="Arduino+ESP8266的远程控制小车"></a>Arduino+ESP8266的远程控制小车</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><h3 id="小车主控板：Arduino-UNO"><a href="#小车主控板：Arduino-UNO" class="headerlink" title="小车主控板：Arduino UNO"></a>小车主控板：Arduino UNO</h3><p>​        Aruduino平台于2005年诞生，两位就职于米兰设计学院的教授，希望开发一款具有软件开发功能的开源的硬件实验平台，于是在他们的合作下，Arduino应运而生。Arduino的编程的语言脱胎于C，如果你有了C语言的学习经验的话，在了解了基本的语言特点和语法之后，便能够非常快速的在Arduino上进行独立的开发工作。关于Arduino的语言，主要有一下两部分，其一是setup()函数，该函数的作用只要在于对系统进行初始化，对相应的引脚进行定义，比如设置输入还是输出模式。第二部分是loop()函数，该函数是用来编写对应的功能的，同时loop()函数将启动硬件部分。不仅如此，Arduino拥有丰富的库文件，分为：官方提供和开发者自定义两种类型。 </p><p>​        正如上文提到的，Arduino同时兼具软件开发的功能，拥有着自己的软件开发环境——Arduino IDE。它最为显著的特点就是可以跨多个平台运行，极大方便了使用。目前支持的平台包括：Linux、Windows和MacOS等。Arduino IDE是针对Arduino开发板的一个集成开源的编译软件，操作界面简单、语言风格与C语言相近、使用的库文件是开源的并且简单的代码可以直接通过串口进行下载。对于使用Arduino的开发者来说，这是一款首选的开发环境。<br>   <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071605373.png" alt="ArduinoIDE"></p><p>​        ArduinoIDE是基于processing IDE开发的，是初学者十分的友好，能够快速的掌握，并具有很高的灵活性。Arduino的语言对于avr-gcc库二次封装，因而不需要太多的单片机和编程基础，便可以进行快速的开发。它的工作流程为，在开发者编写好代码，编译后，将语言转换成C++，再用avr-gcc将编译语言转换成二进制，这样一来，开发者编写的内容才能够背Arduino的硬件识别，程序才能够运行。这串代码通过USB接口连接到电脑，再上传到Arduino的存储器进行存储。</p><p>​        在开发者使用Arduino IDE的时候，要做好以下的准备工作：在PC端下载对应硬件的驱动，选择合适的端口。这些步骤完成之后，便可开始程序的编写。Arduino还有第三方的图形化编程软件，极大地降低了对开发者的编程能力的要求，只要能够符合逻辑的设计出功能，按照规定的方式设置对应的参数，便可以下载程序到硬件开发板进行使用。</p><p><a href="https://www.arduino.cc/en/software">Arduino软件下载</a><br><a href="https://www.arduino.cn/">Arduino中文社区</a></p><p>​        小车选用的是Arduino UNO的开发板，搭载芯片为ATmega328p。</p><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071605635.png" alt="ArduinoUNO"></p><p>​        同时为了方便对控制小车其他配件，选用了一块配套的功能转接板，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071606505.png" alt="功能转接板"></p><p>​                                                                                                        </p><h3 id="远程连接模块：ESP8266开发板"><a href="#远程连接模块：ESP8266开发板" class="headerlink" title="远程连接模块：ESP8266开发板"></a>远程连接模块：ESP8266开发板</h3><p>小车采用ESP-12E开发板（NoteMCU）作为WIFI连接的模块，通过该块开发板连接物联网云平台，实现远程的控制实现。<br>        <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071610875.jpg" alt="EPS8266">    </p><h3 id="其他配件"><a href="#其他配件" class="headerlink" title="其他配件"></a>其他配件</h3><p>小车还需要的配件包括：四个直流电机，底盘，车轮，螺丝（若干），铜柱（若干），电池盒，可充电电池。</p><h2 id="云平台选择——点灯科技（Blinker）"><a href="#云平台选择——点灯科技（Blinker）" class="headerlink" title="云平台选择——点灯科技（Blinker）"></a>云平台选择——点灯科技（Blinker）</h2><p><a href="https://www.diandeng.tech/home">官网首页</a></p><p><a href="https://www.diandeng.tech/doc">开发文档</a></p><h2 id="远程控制设计"><a href="#远程控制设计" class="headerlink" title="远程控制设计"></a>远程控制设计</h2><h3 id="小车控制"><a href="#小车控制" class="headerlink" title="小车控制"></a>小车控制</h3><p>远程控制功能主要分为两个主要部分，分别是对小车的动作控制和云平台连接。</p><p>小车的行动通过控制电机的转速来实现，单片机的I/O口输出不同的信号，改变驱动电路中PWM的比例值，进而对电机的转速进行调控。将对应的电机状态用函数进行封装，配合不同指令调用对应的函数来实现对小车的控制。</p><p>小车基本动作的函数如下表所示：</p><p>​                                                                                        小车基本动作函数</p><table><thead><tr><th>函数名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>run()</td><td>小车向前进</td><td>左右电机前进</td></tr><tr><td>brake()</td><td>小车停止</td><td>左右电机停止</td></tr><tr><td>left()</td><td>小车左转</td><td>右电机前进左电机停止</td></tr><tr><td>right()</td><td>小车右转</td><td>右电机停止左电机前进</td></tr><tr><td>back()</td><td>小车后退</td><td>左右电机反转</td></tr></tbody></table><h3 id="云平台连接"><a href="#云平台连接" class="headerlink" title="云平台连接"></a>云平台连接</h3><p>云平台远程连接采用ESP-12E开发板实现，首先通过ESP-12E板和物联网云平台（采用的是Blinker平台）进行远程连接，首先给开发板刷入Blinker的固件，当设备连接启动后，Arduino板通过串口向ESP-12E开发板发送AT指令，进行WIFI连接。连接成功后，就可以通过手机端向云平台发送指令，再由云平台发送给ESP-12E，Arduino通过串口读取指令，调用相应的动作函数。</p><p>​                                                                                            AT指令字段说明</p><table><thead><tr><th>AT指令</th><th>BLINKER_WIFI=0</th><th>3275431b24545</th><th>f55</th><th>bruce6545555</th></tr></thead><tbody><tr><td>说明</td><td>模块工作于透传模式</td><td>绑定设备的密钥</td><td>WIFI名称</td><td>WIFI密码</td></tr></tbody></table><p>Bilnker云平台远程连接，主要分为新建组件、设置回调函数、绑定组件与回调函数三个步骤，主要的函数说明如下。</p><p>​                                                                                        远程连接主要函数说明</p><table><thead><tr><th>函数名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>BlinkerButton ButtonRun(“btn-run”);</td><td>创建Button对象，键值为“btn-run”</td><td>对应Blinker app上的按键控件</td></tr><tr><td>void  buttonRun_callback(const String &amp; state)</td><td>获取按键的状态</td><td>根据按键的触发状态执行对应语句</td></tr><tr><td>ButtonRun.attach(buttonRun_callback)</td><td>绑定控件和对应的回调函数</td><td></td></tr></tbody></table><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="小车控制部分"><a href="#小车控制部分" class="headerlink" title="小车控制部分"></a>小车控制部分</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment">  前进  按下发出 ONA  </span><br><span class="hljs-comment">  后退：按下发出 ONB  </span><br><span class="hljs-comment">  左转：按下发出 ONC  </span><br><span class="hljs-comment">  右转：按下发出 OND  </span><br><span class="hljs-comment">  停止：按下发出 ONE  </span><br><span class="hljs-comment">************************************************/</span><br><span class="hljs-keyword">int</span> Left_motor=<span class="hljs-number">8</span>;     <span class="hljs-comment">//左电机(IN3) 输出0  前进   输出1 后退</span><br><span class="hljs-keyword">int</span> Left_motor_pwm=<span class="hljs-number">9</span>;     <span class="hljs-comment">//左电机PWM调速</span><br><br><span class="hljs-keyword">int</span> Right_motor=<span class="hljs-number">11</span>;    <span class="hljs-comment">//右电机(IN1)  输出0  前进   输出1 后退</span><br><span class="hljs-keyword">int</span> Right_motor_pwm=<span class="hljs-number">10</span>;    <span class="hljs-comment">// 右电机PWM调速</span><br><br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">18</span>];<span class="hljs-comment">//串口缓冲区的字符数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>  <span class="hljs-comment">//设定串口和引脚模式</span></span><br><span class="hljs-function"></span>&#123;<br>     Serial.begin(<span class="hljs-number">9600</span>);<br>     Serial.flush();<span class="hljs-comment">//清空串口缓存</span><br>     <br>     Serial.println(<span class="hljs-string">&quot;AT+BLINKER_WIFI=0,3275431b255e,f55,bruce6545555&quot;</span>);<br><br>     pinMode(Left_motor,OUTPUT); <span class="hljs-comment">// PIN 8 8脚无PWM功能</span><br>     pinMode(Left_motor_pwm,OUTPUT); <span class="hljs-comment">// PIN 9 (PWM)</span><br>     pinMode(Right_motor_pwm,OUTPUT);<span class="hljs-comment">// PIN 10 (PWM) </span><br>     pinMode(Right_motor,OUTPUT);<span class="hljs-comment">// PIN 11 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>     <span class="hljs-comment">// 前进</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);   //执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brake</span><span class="hljs-params">()</span>         <span class="hljs-comment">//刹车，停车</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  digitalWrite(Right_motor_pwm,LOW);  <span class="hljs-comment">// 右电机PWM 调速输出0      </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br><br>  digitalWrite(Left_motor_pwm,LOW);  <span class="hljs-comment">//左电机PWM 调速输出0          </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span>         <span class="hljs-comment">//左转(左轮不动，右轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">110</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,LOW);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spin_left</span><span class="hljs-params">()</span>         <span class="hljs-comment">//左转(左轮后退，右轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  digitalWrite(Left_motor,HIGH);  <span class="hljs-comment">// 左电机后退</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">right</span><span class="hljs-params">()</span>        <span class="hljs-comment">//右转(右轮不动，左轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机不转</span><br>  digitalWrite(Right_motor_pwm,LOW);  <span class="hljs-comment">// 右电机PWM输出0     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">110</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spin_right</span><span class="hljs-params">()</span>        <span class="hljs-comment">//右转(右轮后退，左轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,HIGH);  <span class="hljs-comment">// 右电机后退</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机PWM输出1     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">50</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">50</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整    </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">back</span><span class="hljs-params">()</span>          <span class="hljs-comment">//后退</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,HIGH);  <span class="hljs-comment">// 右电机后退</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,HIGH);  <span class="hljs-comment">// 左电机后退</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);   //执行时间，可以调整    </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Serial.available() &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//Serial.available()返回串口收到的字节数</span><br>    &#123;<br>       <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>       delay(<span class="hljs-number">100</span>);<span class="hljs-comment">//延时等待串口收完数据，否则刚收到1个字节时就会执行后续程序</span><br>       <span class="hljs-keyword">int</span> numChar = Serial.available();<br>       <span class="hljs-keyword">if</span>(numChar &gt; <span class="hljs-number">15</span>)<span class="hljs-comment">//确认数据不会溢出，应当小于缓冲大小</span><br>       &#123;<br>         numChar = <span class="hljs-number">15</span>;<br>        &#125;<br>       <span class="hljs-keyword">while</span>(numChar--)<br>      &#123;<br>          buffer[index++] = Serial.read();<span class="hljs-comment">//将串口数据一字一字的存入缓冲</span><br>      &#125;<br>      Serial.println(buffer);<br>      splitString(buffer);<span class="hljs-comment">//字符串分割</span><br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">splitString</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>       Serial.print(<span class="hljs-string">&quot;Data entered:&quot;</span>);<br>       Serial.println(data);<br>       <span class="hljs-keyword">char</span> *parameter;<br>       parameter = strtok(data, <span class="hljs-string">&quot; ,&quot;</span>);<span class="hljs-comment">//string token，将data按照空格或者,进行分割并截取</span><br>       Serial.println(parameter);<br>    <span class="hljs-keyword">while</span>(parameter != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    setMove(parameter);<br>    parameter = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; ,&quot;</span>);<span class="hljs-comment">//string token，再次分割并截取，直至截取后的字符为空</span><br>    Serial.println(parameter);<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">16</span>; x++)<span class="hljs-comment">//清空缓冲</span><br>  &#123;<br>   buffer[x] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  &#125;<br>     Serial.flush();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMove</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;A&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;go forward!&quot;</span>); <br>      run();<br>  &#125;<br>  <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;B&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;go back!&quot;</span>); <br>      back(); <br> &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;C&#x27;</span>))<br>   &#123;<br>      Serial.println(<span class="hljs-string">&quot;go left!&quot;</span>); <br>      left();<br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;D&#x27;</span>))<br>   &#123;<br>     Serial.println(<span class="hljs-string">&quot;go right!&quot;</span>); <br>      right(); <br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;E&#x27;</span>))<br>   &#123;<br>      Serial.println(<span class="hljs-string">&quot;Stop!&quot;</span>); <br>      brake(); <br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;F&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;Stop!&quot;</span>); <br>     brake();  <br>   &#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="远程连接部分（烧制在ESP-12E开发板）"><a href="#远程连接部分（烧制在ESP-12E开发板）" class="headerlink" title="远程连接部分（烧制在ESP-12E开发板）"></a>远程连接部分（烧制在ESP-12E开发板）</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLINKER_AT_MQTT</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Blinker.h&gt;</span></span><br><br><span class="hljs-comment">// 新建组件对象</span><br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonRun</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-run&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonBack</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-back&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonLeft</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-left&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonRight</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-right&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonStop</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-stop&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonOn</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-on&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonOff</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-off&quot;</span>)</span></span>;<br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 按键回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonRun_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONA&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONA&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonBack_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONB&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONB&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonLeft_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONC&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONC&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonRight_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;OND&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;OND&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonStop_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonOn_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(<span class="hljs-number">2</span>,LOW);<br>   Serial.write(<span class="hljs-string">&quot;ONF&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonOff_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(<span class="hljs-number">2</span>,HIGH);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Blinker.begin();<br><br>    pinMode(<span class="hljs-number">2</span>,OUTPUT);<br>    <br>    ButtonRun.attach(buttonRun_callback);<br>    ButtonBack.attach(buttonBack_callback);<br>    ButtonLeft.attach(buttonLeft_callback);<br>    ButtonRight.attach(buttonRight_callback);<br>    ButtonStop.attach(buttonStop_callback);<br><br>    ButtonOn.attach(buttonOn_callback);<br>    ButtonOff.attach(buttonOff_callback);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// char ch=Serial.read(); // 读取输入的信息</span><br> <span class="hljs-comment">//Serial.print(ch);  //输出信息</span><br> <span class="hljs-comment">//delay(1000); </span><br>    Blinker.run();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arduino</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的自定义栈用C++实现</title>
    <link href="/2021/Custom-Stack/"/>
    <url>/2021/Custom-Stack/</url>
    
    <content type="html"><![CDATA[<p>用C++实现一个简单的自定义栈</p><span id="more"></span><h1 id="自定义一个栈（In-C-）"><a href="#自定义一个栈（In-C-）" class="headerlink" title="自定义一个栈（In C++）"></a>自定义一个栈（In C++）</h1><h2 id="在头文件-my-stack-h-中自定义栈"><a href="#在头文件-my-stack-h-中自定义栈" class="headerlink" title="在头文件 my_stack.h 中自定义栈"></a>在头文件 my_stack.h 中自定义栈</h2><h3 id="1-自定义栈的类的数据成员和公有函数"><a href="#1-自定义栈的类的数据成员和公有函数" class="headerlink" title="1. 自定义栈的类的数据成员和公有函数:"></a>1. 自定义栈的类的数据成员和公有函数:</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    Type *stk; <span class="hljs-comment">//起始地址</span><br>    <span class="hljs-keyword">int</span> MAXN;  <span class="hljs-comment">//最大容量</span><br>    <span class="hljs-keyword">int</span> top;   <span class="hljs-comment">//指向栈顶元素（下标）</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-keyword">int</span> size); <span class="hljs-comment">//初始化</span><br>    ~<span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;   <span class="hljs-comment">//判断空</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-comment">//判断满</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Type x)</span></span>;    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;           <span class="hljs-comment">//出栈</span><br>    <span class="hljs-function">Type <span class="hljs-title">get_top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//取栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">//栈大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;      <span class="hljs-comment">//最大容量</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-函数的定义："><a href="#2-函数的定义：" class="headerlink" title="2. 函数的定义："></a>2. 函数的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-keyword">int</span> size)<br>&#123;<br>    MAXN = size;<br>    stk = <span class="hljs-keyword">new</span> Type[MAXN];<br>    top = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-comment">//栈初始化</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Stack&lt;Type&gt;::~<span class="hljs-built_in">Stack</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> stk;<br>&#125; <span class="hljs-comment">//析构函数定义</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">full</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (top == MAXN - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;overflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">push</span>(Type x)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;overflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    stk[++top] = x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Type Stack&lt;Type&gt;::<span class="hljs-built_in">get_top</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stk[top];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">int</span> Stack&lt;Type&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">int</span> Stack&lt;Type&gt;::<span class="hljs-built_in">Max</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> -&gt;MAXN;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="在源文件my-stack-cpp中，实现栈的基本操作"><a href="#在源文件my-stack-cpp中，实现栈的基本操作" class="headerlink" title="在源文件my_stack.cpp中，实现栈的基本操作"></a>在源文件my_stack.cpp中，实现栈的基本操作</h2><h3 id="1-创建对象，实现栈的基本操作。"><a href="#1-创建对象，实现栈的基本操作。" class="headerlink" title="1. 创建对象，实现栈的基本操作。"></a>1. 创建对象，实现栈的基本操作。</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;my_stack.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, x, ele, i; <span class="hljs-comment">//最大长度；元素个数；元素；输入元素循环次数</span><br>enter:<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter max length of stack :&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter numbers of elements:&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (x &gt;= n)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;failed! numbers of elements must less than max length!&quot;</span> &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;please enter again!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">goto</span> enter;<br>    &#125;<br>    <span class="hljs-comment">/*创建栈对象*/</span><br>    <span class="hljs-function">Stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The max length is : &quot;</span> &lt;&lt; s.<span class="hljs-built_in">Max</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter your elements:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">/* 循环元素入栈 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x; i++)<br>    &#123;<br>        cin &gt;&gt; ele;<br>        s.<span class="hljs-built_in">push</span>(ele);<br>    &#125;<br>    <span class="hljs-comment">/* 元素出栈 */</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;stack size:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;output elements:&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">empty</span>() != <span class="hljs-literal">true</span>)<br>    &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">get_top</span>() &lt;&lt; endl;    <span class="hljs-comment">//取栈顶元素</span><br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;stack size:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-用模板类的时候注意编写的格式"><a href="#2-用模板类的时候注意编写的格式" class="headerlink" title="2. 用模板类的时候注意编写的格式"></a>2. 用模板类的时候注意编写的格式</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">模板类外函数定义：<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数&gt;<br>函数类型 类名&lt;类型参数&gt;：：成员函数名（形参表）<br>&#123;<br>……<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071603219.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>实践录</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
