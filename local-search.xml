<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git_Command</title>
    <link href="/2022/Git-Command/"/>
    <url>/2022/Git-Command/</url>
    
    <content type="html"><![CDATA[<!-- 转载 --><p>作者: 阮一峰 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">博客地址</a></p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class="hljs-comment"># 下载一个项目和它的整个代码历史</span><br>$ git <span class="hljs-built_in">clone</span> [url]<br></code></pre></div></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加\删除文件"></a>增加\删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [dir]<br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git rm [file1] [file2] ...<br><br><span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git rm --cached [file]<br><br><span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br>$ git mv [file-original] [file-renamed]<br></code></pre></div></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></div></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>$ git branch<br><br><span class="hljs-comment"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class="hljs-comment"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class="hljs-comment"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class="hljs-comment"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></div></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>$ git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></div></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span><br>$ git status<br><br><span class="hljs-comment"># 显示当前分支的版本历史</span><br>$ git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>$ git <span class="hljs-built_in">log</span> -S [keyword]<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class="hljs-built_in">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>$ git <span class="hljs-built_in">log</span> -p [file]<br><br><span class="hljs-comment"># 显示过去5次提交</span><br>$ git <span class="hljs-built_in">log</span> -5 --pretty --oneline<br><br><span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class="hljs-comment"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class="hljs-comment"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class="hljs-comment"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></div></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></div></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br>$ git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br>$ git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></div></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM基础笔记</title>
    <link href="/2022/ARM-Note/"/>
    <url>/2022/ARM-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="产业链"><a href="#产业链" class="headerlink" title="产业链"></a>产业链</h1><ul><li>CUP核</li><li><strong>SOC芯片 — System On Chip （CPU核 + 外围控制器）</strong></li><li>产品</li></ul><h1 id="ARM核工作模式（USA-UFI-SM）"><a href="#ARM核工作模式（USA-UFI-SM）" class="headerlink" title="ARM核工作模式（USA UFI SM）"></a>ARM核工作模式（USA UFI SM）</h1><h2 id="八大工作模式"><a href="#八大工作模式" class="headerlink" title="八大工作模式"></a>八大工作模式</h2><h3 id="用户模式（USR：User）—-唯一非特权"><a href="#用户模式（USR：User）—-唯一非特权" class="headerlink" title="用户模式（USR：User）— 唯一非特权"></a>用户模式（USR：User）— 唯一非特权</h3><ul><li>用户程序的工作模式，运行在<strong>操作系统的用户态</strong>，<strong>没有操作其他硬件的权限</strong></li><li><strong>只有它不是特权模式（privilege mode）</strong></li><li>只能执行处理自己的数据，不能切换到其他模式下，<strong>访问硬件资源</strong>或<strong>切换到其他模式</strong>只能通过<strong>软中断或者异常</strong></li></ul><h3 id="系统模式（SYS：System）—-特权"><a href="#系统模式（SYS：System）—-特权" class="headerlink" title="系统模式（SYS：System）— 特权"></a>系统模式（SYS：System）— 特权</h3><ul><li><strong>不受用户模式的限制</strong>，用户模式核系统模式共用一套寄存器</li><li>操作系统的一些特权任务，可以用该模式访<strong>问一些受控资源</strong></li></ul><h3 id="终止模式（ABT：Abort）—-异常"><a href="#终止模式（ABT：Abort）—-异常" class="headerlink" title="终止模式（ABT：Abort）— 异常"></a>终止模式（ABT：Abort）— 异常</h3><ul><li>用域支持<strong>虚拟内存或存储器保护</strong></li><li><strong>用户程序访问非法地址、没有权限的地址，进入该模式</strong>（如：段错误）</li></ul><h3 id="未定义模式（UDF：Undefined）—-异常"><a href="#未定义模式（UDF：Undefined）—-异常" class="headerlink" title="未定义模式（UDF：Undefined）— 异常"></a>未定义模式（UDF：Undefined）— 异常</h3><ul><li>用于支持硬件协处理器的软件仿真</li><li><strong>CPU在指令的译码阶段不能识别该指令操作</strong>时，进入该模式</li></ul><h3 id="快速中断模式（FIQ：Fast-Interrupt-Request）—-异常"><a href="#快速中断模式（FIQ：Fast-Interrupt-Request）—-异常" class="headerlink" title="快速中断模式（FIQ：Fast Interrupt Request）— 异常"></a>快速中断模式（FIQ：Fast Interrupt Request）— 异常</h3><ul><li>用于处理对<strong>时间要求紧急的中断请求</strong>， 主要用于<strong>高速数据传输及通道处理</strong></li></ul><h3 id="一般中断模式（IRQ：Interrupt-Request）—-异常"><a href="#一般中断模式（IRQ：Interrupt-Request）—-异常" class="headerlink" title="一般中断模式（IRQ：Interrupt Request）— 异常"></a>一般中断模式（IRQ：Interrupt Request）— 异常</h3><ul><li>也叫普通中断，用于<strong>处理一般中断请求，通常在硬件产生中断信号会自动进入该模式</strong></li><li>可以自由访问系统硬件资源</li></ul><h3 id="管理模式（SVC：Supervisor）—-异常"><a href="#管理模式（SVC：Supervisor）—-异常" class="headerlink" title="管理模式（SVC：Supervisor）— 异常"></a>管理模式（SVC：Supervisor）— 异常</h3><ul><li>CPU上电后的默认模式，主要用作<strong>系统初始化（复位异常），软中断处理</strong></li><li><strong>用户模式下，用户程序请求使用硬件资源时，通过软中断进入该模式</strong></li></ul><h3 id="安全监控模式（MON：Monitor）"><a href="#安全监控模式（MON：Monitor）" class="headerlink" title="安全监控模式（MON：Monitor）"></a>安全监控模式（MON：Monitor）</h3><ul><li><strong>TrustZone — 讲SOC的硬件和软件资源划分程安全和非安全两个世界</strong></li><li>安全世界：所有需要保密的操作 — 指纹识别、密码处理、数据加解密等</li><li>非安全世界：用户操作系统、各种应用程序</li><li>两个世界通过Monitor Mode的模式进行转换</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>唯一非特权：User</li><li>五大异常模式：ABT、UDF、FIQ、IRQ、SVC</li><li>安全模式：MON</li><li>中断和异常的区别：异常包含了中断，中断只是异常的一种</li></ul><h1 id="寄存器资源"><a href="#寄存器资源" class="headerlink" title="寄存器资源"></a>寄存器资源</h1><h2 id="寄存器分类-（Registers）"><a href="#寄存器分类-（Registers）" class="headerlink" title="寄存器分类 （Registers）"></a>寄存器分类 （Registers）</h2><ul><li><p><strong>ARM态</strong>通用寄存器和程序计数器 — R0~R15</p></li><li><p><strong>ARM态</strong>程序状态寄存器 — CPSR、SPSR</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/ARM_Registers.png" style="zoom: 67%;" /><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li><p><strong>R0~R10</strong> — 存放用户数据</p></li><li><p><strong>R11</strong> （fp：frame-pointer）— 栈帧指针 记录一个<strong>栈空间的起始地址</strong></p></li><li><p><strong>R12</strong>（ip：The Intra-Procedure-call scratch register）— <strong>临时存储sp</strong>（R13）</p></li><li><p><strong>R13</strong>（sp：stack pointer）— <strong>栈指针寄存器， 栈空间的结束地址</strong></p></li><li><p><strong>R14</strong>（lr：link register）— <strong>发送跳转，保存PC寄存器的值</strong></p></li><li><p><strong>R15</strong>（pc：program counter）— <strong>程序计数器，存放CPU需要执行的下一条指令的内存地址</strong></p></li><li><p><strong>CPSR</strong>（Current Program Status Register）— 记录当前CPU状态</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/CPSR.png" style="zoom: 67%;" /></blockquote></li><li><p><strong>SPSR</strong>（Saved Program Status Register）— 异常产生时候，保存CPSR的值</p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>ARM寄存器 — 40个，一种模式最多 —18个寄存器</p></li><li><p>所有模式共享 — R0~R7、R15、CPSR</p></li><li><p>除FIQ其他模式共享 — R8~R12</p></li><li><p>5大异常模式私有 — R13~R14、SPSR</p></li><li><p>MON私有 — R13~R14、SPSR</p></li><li><p><strong>FIQ — 中断更快的三大原因</strong></p><blockquote><ul><li>更多私有寄存器，私有寄存器使用不需要做保护，FIQ恢复现场更快</li><li>FIQ在异常向量表的最高位，省去了跳转的过程，速度更快</li><li>FIQ的处理优先级比IRQ更高，甚至可以打断正在执行的IRQ</li></ul></blockquote></li><li><p><strong>User 和System模式没有SPSR</strong>，因为它们产生异常时，跳转到其他模式执行，是他们的状态被其他模式保存</p></li></ul><h1 id="常用ARM核指令"><a href="#常用ARM核指令" class="headerlink" title="常用ARM核指令"></a>常用ARM核指令</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><code>&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125;     &lt;Rd&gt; ,&lt;Rn&gt;&#123;, &lt;operand2&gt;&#125;</code></p><ul><li><p>opcode : 操作码 </p></li><li><p>cond ：条件</p><blockquote><ul><li>NE、EQ、GT、LT、GE、LE</li></ul></blockquote></li><li><p>S：指令执行结果，影响CPSR的N，Z，C，V</p></li><li><p>Rd：目标寄存器，存放指令执行结果R0~R15</p></li><li><p>Rn：操作数1，必须是寄存器</p></li><li><p>operand2：操作数2</p><blockquote><ul><li><p>立即数：<code>#100</code> ,一个常数，一个8位常数通过循环右移偶数位，得到它，则该数字为合法立即数</p><blockquote><p>把一个数转换为32bit，16进制</p><ul><li>除零外，仅有一位数，为合法立即数</li><li>除零外，仅有两位数，且相邻（包括首尾），为合法立即数</li><li>除零外，仅有三位数字，且相邻（包括中间有0，首尾相邻），这三位数，最高位只能取1、2、3；最低位只能取4、8、C，这样的组合为合法立即数</li></ul></blockquote></li><li><p>寄存器</p></li><li><p>寄存器移位：只能寄存器移位</p><blockquote><ul><li>LSL:逻辑左移</li><li>LSR:逻辑右移</li><li>ASR:算数右移</li></ul></blockquote></li></ul></blockquote></li></ul><p><strong>注意：操作数1，只能是寄存器</strong></p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><ul><li><p>MOV：<code>MOV 目标寄存器，操作数2</code></p><blockquote><p>将操作数2的值 赋值给目标寄存器</p></blockquote></li><li><p>MVN：<code>MVN 目标寄存器 , 操作数2</code></p><blockquote><p>将操作数2 取反的值，给目标寄存器</p></blockquote></li><li><p>LDR：<code>LDR 目标寄存器， =数据</code></p><blockquote><p>任意数据传送到目标寄存器</p><ul><li>如果后面是一个合法立即数，翻译成MOV指令</li><li>如果是非法立即数，翻译成 LDR Rn, [PC]</li></ul></blockquote></li></ul><p><strong>注意：</strong> <strong>MOV指令 用立即数</strong>，<strong>效率更高</strong>，CPU获取指令时，指令和数据都翻译成机器码，指令和数据同时获取，因此效率更高</p><p>但，不是所有数据都能被和指令同时获取，因此，有了合法立即数的概念，一条指令中八位是数据位</p><h2 id="数据计算指令"><a href="#数据计算指令" class="headerlink" title="数据计算指令"></a>数据计算指令</h2><ul><li><p>ADD：<code>ADD 目标寄存器，操作数1，操作数2</code></p></li><li><p>SUB：<code>SUB 目标寄存器，操作数1，操作数2</code></p></li><li><p>MUL：<code>目标寄存器, 操作数1，操作数2</code></p><blockquote><p><strong>注意：MUL的目标寄存器，和操作数1，编号不能相同</strong></p><p><strong>MUL 两个操作数都要是简单寄存器</strong></p></blockquote></li></ul><h2 id="位运算指令"><a href="#位运算指令" class="headerlink" title="位运算指令"></a>位运算指令</h2><ul><li><p>AND：<code>AND 目标寄存器，操作数1，操作数2</code></p><blockquote><p>将操作数1，<strong>按位与</strong> ，操作数2，结果存放在目标寄存器</p></blockquote></li><li><p>ORR：<code>ORR 目标寄存器，操作数1，操作数2</code></p><blockquote><p>操作数1，按位或，操作数2，结果存放在目标寄存器</p></blockquote></li><li><p>EOR：<code>EOR 目标寄存器， 操作数1，操作数2</code></p><blockquote><p>将操作数1，按位异或，操作数2，结果放在目标寄存器</p></blockquote></li><li><p>BIC：<code>BIC 目标寄存器，操作数1，操作数2</code></p><blockquote><p>目标寄存器 = 操作数1 &amp; ~操作数2</p></blockquote><p>如果想把data的某些位，变成自己想要的值：</p><ul><li><p><strong>先将对应的位清0，然后再或上对应的值（对应的值左移得到）</strong></p></li><li><blockquote><p>清0：先对应位数，几位就几个1，从第几位开始，就左移几位，再取反，再和源数字按位与&amp;</p><p>置1：目标数字，左移，从第几位开始就左移几位，再和源数字按位或 |</p></blockquote></li></ul></li></ul><h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><ul><li><p>CMP：<code>CMP 寄存器，操作数2</code></p><blockquote><p>CMP指令会自动影响CPSR的N、Z、C、V</p><p>CMP执行时不关心之前执行了什么指令，只关心CPSR的NZCV表示的条件是否满足条件，满足执行，不满足不执行</p></blockquote></li></ul><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul><li><p>B/BL ：只能跳转+/- 32M范围，跳转到一个指定标签</p><blockquote><p><code>B 标签</code></p><p><code>BL 标签</code> ：BL跳转之前，将跳转前的PC（R15）值保存在LR（R14）</p></blockquote></li><li><p>给PC赋值：没有范围限制</p><p><code>LDR PC , =标签名</code></p></li></ul><h2 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h2><h3 id="单个数据访问"><a href="#单个数据访问" class="headerlink" title="单个数据访问"></a>单个数据访问</h3><ul><li><p>LDR（Load Register）：将内存的值加载到寄存器（读内存）</p></li><li><p>STR（Store Register）：将寄存器的值写入内存（写内存）</p></li><li><p><strong>寄存器间接寻址：</strong></p><blockquote><ul><li>LDR r0, <strong>[r1]</strong> —-&gt; (r0 = *r1)</li><li>STR r0，**[r1]** —-&gt;  (*r1 = r0)</li></ul></blockquote></li><li><p><strong>基址变址寻址</strong>：将基地址寄存器 + 指令中给出的偏移量 = 数据存放的地址</p><blockquote><ul><li><p>前索引：</p><blockquote><ul><li>STR r0, [r1, #4] —-&gt; *(r1 + 4) = r0</li><li>LDR r0, [r1, #4] —-&gt; r0 = *(r1 + 4)</li></ul></blockquote></li><li><p>后索引:</p><blockquote><ul><li>STR r0, [r1], #4 —-&gt; *r1 = r0 ; <strong>r1 = r1 + 4</strong></li><li>LDR r0, [r1], #4 —-&gt; r0 = *r1; <strong>r1 = r1  + 4</strong></li></ul></blockquote></li><li><p>自动索引:</p><blockquote><ul><li><p>STR r0, [r1, #4] ! —-&gt; *(r1 + 4) = r0; <strong>r1 = r1 + 4</strong></p></li><li><p>LDR r0, [r1, #4] ! —-&gt; r0 = *(r1 + 4); <strong>r1 = r1 + 4</strong></p></li></ul></blockquote></li></ul></blockquote></li></ul><h3 id="多个数据访问"><a href="#多个数据访问" class="headerlink" title="多个数据访问"></a>多个数据访问</h3><ul><li><p>LDM ：读内存数据，加载到多个寄存器</p><blockquote><p><strong>LDM</strong> {条件}{s} &lt;MODE&gt; 基质寄存器 {!} , {Reglist}^</p></blockquote></li><li><p>STM：将多个寄存器的值，存储到一块内存</p><blockquote><p><strong>STM</strong> {条件}{s} &lt;MODE&gt; 基质寄存器 {!} , {Reglist}^</p></blockquote></li><li><p>MODE：</p><blockquote><ul><li>IA （increase after）— 后增加地址</li><li>IB （increase before）— 先增加地址</li><li>DA（decrease after）— 后减少地址</li><li>DB（decrease before）— 先减少地址</li></ul></blockquote></li><li><p>基址寄存器 ：存放内存的起始地址</p></li><li><p>！：最后更新基址寄存器的值</p></li><li><p>Reglist ：寄存器列表</p><blockquote><ul><li>多个寄存器从小到大，中间用“，”隔开{r0, r1, r2} 或 {r0, r7- r10}</li><li>寄存器编号大的 —- 内存高地址； 寄存器编号小的 —- 内存低地址</li></ul></blockquote></li><li><p>^ : 它存在：</p><blockquote><ul><li>Reglist 没有PC寄存器的时候，操作的寄存器是用户模式下的寄存器</li><li>在LDM指令中，有PC的时候，数据传输时，会将SPSR的值拷贝到CPSR，用于异常返回</li></ul></blockquote></li></ul><h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><ul><li><p>进（压）栈： <strong>stmfd sp!</strong> , {寄存器列表}</p></li><li><p>出栈：<strong>ldmfd sp!</strong> , {寄存器列表}</p></li><li><p>进行栈操作前<strong>，必须先设置sp的值</strong></p></li><li><p>进栈和出栈方式一样，<strong>ATPCS标准规定满减栈</strong></p></li><li><p>几种栈操作方式：</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/stack.jpg"></blockquote></li></ul><h2 id="CPSR-SPSR操作指令"><a href="#CPSR-SPSR操作指令" class="headerlink" title="CPSR/SPSR操作指令"></a>CPSR/SPSR操作指令</h2><ul><li><p>读操作：</p><blockquote><ul><li><p>MRS Rn, CPSR/SPSR</p><p>将状态寄存器的值，读到通用寄存器</p></li></ul></blockquote></li><li><p>写操作：</p><blockquote><ul><li><p>MSR CPSR/SPSR， Rn</p><p>将通用寄存器的值，写到状态寄存器</p></li></ul></blockquote></li></ul><h1 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h1><p>（instruction pipeline）—- 以三级流水线为例</p><ul><li>预取 （fetch）— <strong>PC寄存器工作在预取阶段</strong></li><li>译码 （decode）</li><li>执行 （execute）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/Instruction_pipeline.png"></p><h1 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h1><p>**链接地址:**编译器在编译程序的时候，指定的地址，指定这个地址的目的是期望程序在指定的链接地址执行</p><p>**运行地址:**程序实际在内存中的运行地址</p><p>伪指令：为了方便程序员使用，<strong>编译器设计的指令</strong>，该指令ARM核无法识别，需要编译器进行翻译</p><h2 id="常用的伪指令"><a href="#常用的伪指令" class="headerlink" title="常用的伪指令"></a>常用的伪指令</h2><ul><li><p>LDR r0, =0x999  —-&gt; LDR r0, [PC]</p></li><li><p><strong>LDR r0,</strong> **=Label **  —-&gt; LDR r0, [PC ,# 固定偏移量] </p><blockquote><p>读取Label标签表示的地址，存放到r0中，<strong>这个标签最终表示的地址受链接地址的影响</strong></p><blockquote><p>编译器：根据指定的代码开始地址，算出Label标签对应地址，存放在内存中，，通过内存访问指令，根据<strong>PC + 固定偏移量</strong>，读取内存值。换言之，<strong>代码编译结束时候，PC + 固定偏移量表示的内存地址中存放的数据就已经确定死了</strong></p></blockquote></blockquote></li><li><p>LDR r0,  Label  —-&gt; LDR r0, [PC, # 固定偏移量]</p><blockquote><p>读取Label标签表示的地址的内容</p></blockquote></li><li><p><strong>ADR r0, Label</strong> —&gt; <strong>根据当前PC的值 +/-偏移量，动态获取当前Label表示的内存地址</strong></p></li><li><p>问题：如何判别代码在实际内存中运行的地址？</p><blockquote><ul><li>ADR r0，_start 可以知道，因为它根据PC值，动态获取</li><li>LDR r0, =_start 无法知道，这条指令不论在哪运行，r0的值都是固定的（取决于指定的链接地址）</li></ul></blockquote></li></ul><h1 id="汇编与C混合编程"><a href="#汇编与C混合编程" class="headerlink" title="汇编与C混合编程"></a>汇编与C混合编程</h1><h2 id="汇编调用C语言"><a href="#汇编调用C语言" class="headerlink" title="汇编调用C语言"></a>汇编调用C语言</h2><ul><li><p>ATPCS：</p><blockquote><ul><li><p><strong>参数传递</strong>：函数参数传递的时候，<strong>前4个参数通过r0 - r3来传递，超过4个的参数通过栈传递</strong></p></li><li><p><strong>函数返回</strong>：函数返回值通过 r0 带回</p></li></ul></blockquote></li><li><p><strong>注意：！！！调用C语言之前，必须先设置SP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">mov r0, #3<br>mov r1, #5<br>ldr sp, =0x40001ff0 @!!! 必须设置sp<br>bl add //add是.c文件中的一个函数<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="C语言中内嵌汇编-—-GCC编译器为例"><a href="#C语言中内嵌汇编-—-GCC编译器为例" class="headerlink" title="C语言中内嵌汇编 — GCC编译器为例"></a>C语言中内嵌汇编 — GCC编译器为例</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> (<br><span class="hljs-string">&quot;指令1\n&quot;</span><br>    <span class="hljs-string">&quot;指令2\n&quot;</span><br>    ...<br>    :输出列表<br>    :输入列表<br>    :修改列表(通用的寄存器)<br>);<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">int</span> d;<br><br><span class="hljs-comment">//输出列表 --- 将寄存器值输出到C变量</span><br>:<span class="hljs-string">&quot;=r&quot;</span>(c), <span class="hljs-string">&quot;=r&quot;</span>(d)<br>    <br><span class="hljs-comment">//输入列表 ---- 将C变量输入到寄存器</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>:<span class="hljs-string">&quot;r&quot;</span>(a), <span class="hljs-string">&quot;r&quot;</span>(b)<br>    <br><span class="hljs-comment">//修改列表 ---- 在内联汇编的时候，发生修改的寄存器</span><br>:<span class="hljs-string">&quot;r0&quot;</span>, <span class="hljs-string">&quot;r1&quot;</span>, <span class="hljs-string">&quot;r2&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>C变量的引用， 从输出列表到输入列表开始编号：第一个C变量%0，第二个C变量 %1….</strong></p><h1 id="Volatile关键字-（重点）"><a href="#Volatile关键字-（重点）" class="headerlink" title="Volatile关键字 （重点）"></a>Volatile关键字 （重点）</h1><h2 id="gcc优化"><a href="#gcc优化" class="headerlink" title="gcc优化"></a>gcc优化</h2><h3 id="优化思想"><a href="#优化思想" class="headerlink" title="优化思想"></a>优化思想</h3><ul><li>如果之前已经把变量的对应的内存数据读到寄存器中，当需要再次读取该变量所对应的内存数据的时候，为了提高效率，编译器会直接使用上一次寄存器中的值，而不再重新从内存读值</li></ul><h3 id="优化级别"><a href="#优化级别" class="headerlink" title="优化级别"></a>优化级别</h3><ul><li>O1：一级优化</li><li>O2（speed）/Os（size）：二级优化</li><li>O3：三级优化</li></ul><h3 id="优化的问题"><a href="#优化的问题" class="headerlink" title="优化的问题"></a>优化的问题</h3><p>如果内存中的值，已经被其他的执行单元（比如其他线程、中断）进行了更改，而优化后的代码，每次从寄存器读值，就会造成寄存器中的值和内存中的值不一致的问题</p><h2 id="Volatile的作用"><a href="#Volatile的作用" class="headerlink" title="Volatile的作用"></a>Volatile的作用</h2><p>volatile修饰一个变量，<strong>防止编译器优化（本质）</strong>，告诉编译器每次使用该变量时，必须从变量所在的内存重新读值</p><ul><li><p>有中断处理函数的代码，使用了全局变量，需要注意什么问题？</p><blockquote><p>定义全局变量的时候，<strong>需要加volatile修饰</strong></p></blockquote></li></ul><h1 id="ARM-编程命令"><a href="#ARM-编程命令" class="headerlink" title="ARM 编程命令"></a>ARM 编程命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">arm-none-eabi-gcc -c .\start.s -o .\start.o  //只编译不链接<br>arm-none-eabi-gcc -c .\key_led.c -o .\key_led.o<br>arm-none-eabi-ld -Ttext=0x40000000 .\start.o .\key_led.o -o key_led.elf //链接，指定链接地址<br>arm-none-eabi-objcopy -O binary .\key_led.elf .\key_led.bin //格式转换，去除elf信息头<br></code></pre></div></td></tr></table></figure><h1 id="PWM定时器"><a href="#PWM定时器" class="headerlink" title="PWM定时器"></a>PWM定时器</h1><h2 id="PWM-脉冲宽度调制"><a href="#PWM-脉冲宽度调制" class="headerlink" title="PWM 脉冲宽度调制"></a>PWM 脉冲宽度调制</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/PWM Timer.png" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/pwm.gif" style="zoom:150%;" /><p>FS4412开发板中，PWM的时钟频率为 100MHz</p><p>三星的计数器是递减计数器</p><h1 id="串口通信接口"><a href="#串口通信接口" class="headerlink" title="串口通信接口"></a>串口通信接口</h1><h2 id="电平标准-—-外部的硬件电路决定"><a href="#电平标准-—-外部的硬件电路决定" class="headerlink" title="电平标准 — 外部的硬件电路决定"></a>电平标准 — 外部的硬件电路决定</h2><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/RS232、RS485.png"  /><h2 id="RS232-和-RS485-（重点）"><a href="#RS232-和-RS485-（重点）" class="headerlink" title="RS232 和 RS485 （重点）"></a>RS232 和 RS485 （重点）</h2><p> <strong>RS232 vs RS485</strong></p><ul><li>RS232  三个线(RXD,TXD,GND), 全双工，交叉连接<br>RS485  三个线(A,B,GND),         半双工，A-A；B-B</li><li>RS485 传输距离更远</li><li>RS485 速度更快</li><li>RS485 抗干扰更好，RS485采用传输差分信号，A-B线电压差确定传输的一位数据</li><li>RS232 1: -(3<del>15v)  0: +(3</del>15)v  , RS485  1: +(2<del>6v)  0: -(2</del>6v)</li><li>RS485支持多点通信，RS232不支持</li></ul><h2 id="UART-—-芯片内部的异步收发器"><a href="#UART-—-芯片内部的异步收发器" class="headerlink" title="UART — 芯片内部的异步收发器"></a>UART — 芯片内部的异步收发器</h2><ul><li>UART— 芯片内部的串口通信标准的数据发送格式</li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/UART.png" style="zoom: 67%;" /><p>UART （Universal Asynchronous Receiver and Transmitter）—- 通用异步收发器</p><p>串口:数据是一位一位的发<br>并口:数据是多位一起发</p><ul><li><p>UART串口通信参数：</p><blockquote><ul><li>波特率 ：双方的通信速度</li><li>数据位：发送数据的位数 —- 先发送低位</li><li>停止位：表示收发停止</li><li>校验位：检查数据是否错误，奇偶校验（只能发现一位错误）</li><li>流量控制：需要硬件支持</li></ul></blockquote></li></ul><h3 id="串口通信数据错误："><a href="#串口通信数据错误：" class="headerlink" title="串口通信数据错误："></a>串口通信数据错误：</h3><ul><li>电平标准</li><li>波特率</li><li>数据位</li><li>停止位</li><li>校验位</li></ul><h3 id="系统三大总线"><a href="#系统三大总线" class="headerlink" title="系统三大总线"></a>系统三大总线</h3><p>数据、地址、控制</p><h3 id="DMA模式"><a href="#DMA模式" class="headerlink" title="DMA模式"></a>DMA模式</h3><p>Direct Memory Access：设备直接访问内存，不需要经过CPU</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul><li><p>异常处理流程</p><blockquote><p>​                                                                      <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/Expection Handling.png" style="zoom: 80%;" /></p></blockquote></li></ul><h2 id="ARM核硬件上自动做的事情"><a href="#ARM核硬件上自动做的事情" class="headerlink" title="ARM核硬件上自动做的事情"></a>ARM核硬件上自动做的事情</h2><ul><li><p>CPSR —-拷贝—-&gt; SPSR</p></li><li><p>设置CPSR对应位：</p><blockquote><ul><li>进入ARM态</li><li>进入对应的异常模式</li><li>禁止中断</li></ul></blockquote></li><li><p>保存PC的值到异常模式的 LR</p></li><li><p>将PC设置为异常向量表的对应位置：</p><blockquote><table><thead><tr><th>偏移量</th><th>异常</th></tr></thead><tbody><tr><td>0x1C</td><td>FIQ</td></tr><tr><td>0x18</td><td>IRQ</td></tr><tr><td>0x14</td><td>(Reserved)</td></tr><tr><td>0x10</td><td>Data Abort</td></tr><tr><td>0x0C</td><td>Prefetch Abort</td></tr><tr><td>0x08</td><td>Software Interrupt</td></tr><tr><td>0x04</td><td>Undefined Instruction</td></tr><tr><td>0x00</td><td>Reset</td></tr></tbody></table><p>&lt;Vector Table&gt;</p></blockquote></li><li><p>异常优先级、对应处理器模式、返回地址：</p><blockquote><table><thead><tr><th>优先级</th><th>异常</th><th>模式</th><th>返回地址</th></tr></thead><tbody><tr><td>1  最高</td><td>Reset</td><td>SVC</td><td>-</td></tr><tr><td>2</td><td>Data Abort</td><td>Abort</td><td>LR-8</td></tr><tr><td>3</td><td>FIQ</td><td>FIQ</td><td>LR-4</td></tr><tr><td>4</td><td>IRQ</td><td>IRQ</td><td>LR-4</td></tr><tr><td>5</td><td>Prefetch Abort</td><td>Abort</td><td>LR-4</td></tr><tr><td>6</td><td>Software Interrupt</td><td>SVC</td><td>LR</td></tr><tr><td>7   最低</td><td>Undefined Instruction</td><td>Undefined</td><td>LR</td></tr></tbody></table></blockquote></li></ul><h2 id="程序员需要做的事情"><a href="#程序员需要做的事情" class="headerlink" title="程序员需要做的事情"></a>程序员需要做的事情</h2><ul><li><p>设置异常向量表（在异常向量表中，写跳转指令，跳转指定异常处理函数）</p></li><li><p>告诉ARM核异常向量表的基地址</p><blockquote><ul><li>cortex-A系列以前，异常向量表可以存放在 0x0000，0000 （低地址）或 0xffff，0000（高地址）；cp15（协处理器）.c1（寄存器）决定异常向量表存放在高地址还是低地址</li><li>cortex-A系列以后，异常向量表可以在任意位置，cp15.c12保存异常向量表的基地址</li></ul></blockquote></li><li><p>编写异常处理函数：</p><blockquote><ul><li><p>设置SP寄存器</p></li><li><p>将通用寄存器R0~R12，进行压栈保护</p></li><li><p>异常处理</p></li><li><p>异常返回</p><blockquote><ul><li>恢复R0~R12 （出栈）</li><li>恢复CPSR</li><li>恢复PC</li></ul></blockquote></li></ul></blockquote></li></ul><h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><ul><li><p>CPU主要两种工作模式：轮询和中断</p><blockquote><ul><li>轮询：不断询问是否要处理事情，但很多时候不满足条件，浪费了CPU的时间</li><li>中断方式：当需要CPU处理的时候，产生一个信号，打断CPU正在做的事情，让CPU处理当前的事情，处理完后，回到打断之前的地方继续执行</li></ul></blockquote></li><li><p>中断处理注意点：</p><blockquote><ul><li>中断打断其他程序的执行，所以中断处理要尽可能的快，不能中断处理耗时过长</li><li>中断打断程序的执行，所以中断处理的时候，需要先保存现场（CPU的状态和CPU内部寄存器的值：压栈保存），中断处理结束，恢复现场</li></ul></blockquote></li></ul><h2 id="中断的五大概念（重点）"><a href="#中断的五大概念（重点）" class="headerlink" title="中断的五大概念（重点）"></a>中断的五大概念（重点）</h2><ul><li><p>中断源：产生中断的源头</p></li><li><p>中断号：SOC芯片厂家对SOC芯片内部<strong>中断源的编号</strong></p></li><li><p>中断处理函数：中断产生后，需要调用执行的函数</p></li><li><p>中断控制器：控制中断的优先级、中断是否被允许产生</p></li><li><p>内部中断和外部中断：</p><blockquote><ul><li><p>内部中断：SOC芯片内部控制器产生的中断</p></li><li><p>外部中断：SOC芯片外部管脚通过电平触发产生的中断</p><blockquote><p>高电平触发、低电平触发</p><p>上升沿触发、下降沿触发</p><p>双边触发</p></blockquote></li></ul></blockquote></li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/interrupt.png" style="zoom: 80%;" /><p>学习使用的FS4412开发板，是三星设计的SOC，一共有160个中断源</p><h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><ul><li><em><strong>中断处理过程</strong></em>：</li></ul><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/interrupt_handling.png" style="zoom: 60%;" /><ul><li><em><strong>MPCore 分布式中断控制系统</strong></em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/MPCore.png"></p><ul><li><em><strong>GIC：</strong></em> (Generic Interrupt Controller)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/GIC.png"></p><h1 id="A-D转换器"><a href="#A-D转换器" class="headerlink" title="A/D转换器"></a>A/D转换器</h1><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;exynos_4412.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;exynos_setup.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CLRINTADC = <span class="hljs-number">0x0</span>; <span class="hljs-comment">//INT_ADCn interrupt clear. Cleared if any value is written.</span><br><br>    <span class="hljs-keyword">int</span> data = ADCDAT &amp; <span class="hljs-number">0xfff</span>;<br>    <span class="hljs-keyword">int</span> v = (<span class="hljs-number">1800</span> * data) / <span class="hljs-number">0xfff</span>;<br><br>    uart_printf(<span class="hljs-string">&quot;%d : %d mv\r\n&quot;</span>, data, v);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   1.8v    0xfff</span><br><span class="hljs-comment">    x      data  </span><br><span class="hljs-comment"> */</span><br>    delay_time(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// A/D conversion starts by enable.</span><br>    ADCCON |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_interrupt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.init ADC</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    16bit 1: 12bit A/D conversion</span><br><span class="hljs-comment">    14bit 1: enable A/D converter prescaler</span><br><span class="hljs-comment">    6¬13bit 132: prescaler value data</span><br><span class="hljs-comment">    ADCMUX 0x3: Analog input channel select</span><br><span class="hljs-comment">    */</span><br>    ADCCON = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>) | (<span class="hljs-number">132</span> &lt;&lt; <span class="hljs-number">6</span>);<br>    ADCMUX = <span class="hljs-number">0x3</span>;<br>    <span class="hljs-comment">//2.init GIC</span><br>    request_irq(<span class="hljs-number">42</span>, adc_handler);<br>    <span class="hljs-comment">//3.init ARM</span><br>    enable_irq();<br>    <span class="hljs-comment">//4.init Combiner</span><br>    INTCOMBINER.IESR2 |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">19</span>);<br>    <span class="hljs-comment">//5.A/D conversion starts by enable.</span><br>    ADCCON |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_interrupt_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    adc_interrupt_init();<br><br>    <span class="hljs-comment">//do_something();</span><br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="IIC总线"><a href="#IIC总线" class="headerlink" title="IIC总线"></a>IIC总线</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>IIC（Inter-Integrated Circuit,又称 IIC）—- 由PHILIPS公司开发的<strong>串口总线，用于连接微控制器及其外围设备</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><ul><li>只有<strong>两条总线线路</strong>:一条串行数据线**(SDA),<strong>一条串行时钟线</strong>(SCL)** </li><li>每个连接到总线的器件都可以使用软件<strong>根据它的唯一的地址来识别</strong> </li><li>传输数据的设备间是简单的<strong>主/从关系</strong> </li><li>主机可以用作主机发送器或主机接收器 </li><li>它是一个真正的多主机总线，<strong>两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏</strong></li><li><strong>串行的8位双向数据传输</strong>，<strong>先发送高位</strong>，位速率在标准模式下可达100kbit/s,在快速模式下可达400kbit/s,在高速模式下可达3.4Mbit/s</li></ul></blockquote><h3 id="IIC总线信号类型"><a href="#IIC总线信号类型" class="headerlink" title="IIC总线信号类型"></a>IIC总线信号类型</h3><p>有3种类型信号：<strong>开始信号、结束信号、响应信号</strong></p><blockquote><ol><li>开始信号(S):SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据 </li><li>结束信号(P):SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据 </li><li>响应信号(ACK):接收器在接收到8位数据后，在第9个时钟周期，拉低 SDA 电平 </li></ol></blockquote><p><strong>注意:   SDA 上传输的数据必须在 SCL 为高电平期间保持稳定，SDA 上的数据只能在 SCL 为低电平期间变化</strong></p>  <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_Bus.png" alt="IIC signal" style="zoom: 67%;" /><h3 id="IIC-总线的数据传输格式"><a href="#IIC-总线的数据传输格式" class="headerlink" title="IIC 总线的数据传输格式"></a>IIC 总线的数据传输格式</h3><p>发送到 <strong>SDA 线上的每个字节必须是8位的，每次传输可以发送的字节数量不受限制。首先传输的是数据的最高位(MSB)</strong></p><p><strong>启动一个传输时，主机先发送 S 信号，然后发出8位数据。这8位数据中前7位为从机的地址，第8位表示传输的方向(0表示写操作，1表示读操作)。从机收到后会发出一个 ACK 信号</strong></p><p><em><strong>Read Sequence</strong></em> </p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_ReadSequence.png" style="zoom:80%;" /></blockquote><p><em><strong>Write Sequence</strong></em></p><blockquote><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_WriteSequence.png" style="zoom:80%;" /></blockquote><p><strong>I^2^C Terms</strong></p><table><thead><tr><th>Signal</th><th>Description</th></tr></thead><tbody><tr><td>S</td><td>Start Condition: SDA goes from high to low while SCL is high</td></tr><tr><td>AD</td><td>Slave I^2^C address</td></tr><tr><td>W</td><td>Write bit (0)</td></tr><tr><td>R</td><td>Read bit (1)</td></tr><tr><td>ACK</td><td>Acknowledge: SDA line is low while the SCL line is high at the 9 ^th^ clock cycle</td></tr><tr><td>NACK</td><td>Not-Acknowledge: SDA line stays high at the 9th clock cycle</td></tr><tr><td>RA</td><td>MPU-60X0 internal register address</td></tr><tr><td>DATA</td><td>Transmit or received data</td></tr><tr><td>P</td><td>Stop condition: SDA going from low to high while SCL is high</td></tr></tbody></table><p><strong>操作芯片的步骤：</strong></p><ul><li>通过原理图或手册，确定通信接口</li><li>确定是IIC或者是其他通信方式之后，找到从机地址（或者其他对应的地址信息）</li><li>查看手册确定寄存器操作方式（读写）</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>底层开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法笔记</title>
    <link href="/2021/Cpp-Note01/"/>
    <url>/2021/Cpp-Note01/</url>
    
    <content type="html"><![CDATA[<p>C++语法学习记录，做一个系统性梳理。</p><span id="more"></span><h1 id="C-学习路线"><a href="#C-学习路线" class="headerlink" title="C++学习路线"></a>C++学习路线</h1><h2 id="C-语言学习"><a href="#C-语言学习" class="headerlink" title="C++语言学习"></a>C++语言学习</h2><p>面向对象编程思想；<br>类的封装，构造和析构、静态成员、对象管理；<br>类的构造(有参构造函数、无参构造、拷贝构造、默认构造函数)和析构；<br>对象动态管理、友元函数、友元类、操作符重载；<br>C++编译器对象管理模型分析；<br>类对象的动态管理(new/delete)；<br>友元函数和友元类；<br>运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；<br>类的继承、多继承及其二义性、虚继承；<br>多态(概念、意义、原理剖析、多态案例)；<br>虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；<br>函数模板、类模板，模板的继承；<br>C++类型转换；<br>C++输入输出流(标准I/O文件I/O 字符流I/O)；<br>C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)</p><h2 id="C-开发"><a href="#C-开发" class="headerlink" title="C++开发"></a>C++开发</h2><ol><li>STL</li><li>设计模式</li><li>数据结构基础<br>顺序存储、链式存储、循环链表；<br>双向链表、栈(顺序和链式)、队列(顺序和链式)；<br>栈的应用、树基本概念及遍历、二叉树；<br>排序算法、并归算法、选择、插入、快速、希尔</li><li>UI界面开发</li><li>Unix/Linux网络服务器</li><li>数据库开发</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo@main/img/C++_StudyPath.png"></p><h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客成长记</title>
    <link href="/2021/blog-building/"/>
    <url>/2021/blog-building/</url>
    
    <content type="html"><![CDATA[<p>总结一下博客搭建的整个过程中，每个功能的实现，都用到了哪些工具。对博客搭建的过程做个回顾，也是为了以后自己想要再使用这些工具的时候方便寻找。</p><span id="more"></span><h1 id="博客框架"><a href="#博客框架" class="headerlink" title="博客框架"></a>博客框架</h1><h2 id="动态博客"><a href="#动态博客" class="headerlink" title="动态博客"></a><del>动态博客</del></h2><p>综合考虑之后，放弃了动态博客搭建。主要精力折腾服务器和数据库，等工作啥稳定说不定会试试。或许忙起来更不想折腾了，唉。<br>看过一些框架：<a href="https://wordpress.org/"><strong>WordPress</strong></a> 、<a href="http://typecho.org/"><strong>Typecho</strong></a> 等</p><h2 id="静态博客"><a href="#静态博客" class="headerlink" title="静态博客"></a>静态博客</h2><p>了解过的：<a href="https://gohugo.io/"><strong>Hugo</strong></a>;    <a href="https://vuepress.vuejs.org/zh/"><strong>VuePress</strong></a>;<br>使用过的：<br><a href="https://gridea.dev/"><strong>Gridea</strong></a>;<br>使用过的第一款静态博客框架，方便快捷，一个客户端全搞定，不要Git等环境支持。<br>但是，成也萧何败也萧何，它的客户端同步太不稳定了，经常失败。最后，我还是自己手动Git push到远程仓库。<br>好处在于不需要关注其他，专心在博客写作上。<br><a href="https://hexo.io/zh-cn/"><strong>Hexo</strong></a>;</p><h1 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h1><p>写作主要用Markdown，使用的两款编辑器：<br>主力 <a href="https://typora.io/"><strong>Typora</strong></a>;备用<a href="https://code.visualstudio.com/"><strong>vsCode</strong></a>;<br>写博客主要用的Typora，vsCode也能写Markdown，但只要用来写代码。</p><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="图床管理工具："><a href="#图床管理工具：" class="headerlink" title="图床管理工具："></a>图床管理工具：</h2><p><a href="https://molunerfinn.com/PicGo/"><strong>PicGo</strong></a>; 网上推荐的比较多，支持主流的图床，使用体验还可以。</p><h2 id="图床："><a href="#图床：" class="headerlink" title="图床："></a>图床：</h2><p>图床选择太多了，我发图不多，懒得折腾了，反正有现成GitHub账号就用仓库但图床了。<br>但是，这种用法确实不太好，背离了GitHub的初衷，如果仓库塞太多图片是会被警告的。</p><h3 id="对象存储服务做图床"><a href="#对象存储服务做图床" class="headerlink" title="对象存储服务做图床:"></a><del>对象存储服务做图床</del>:</h3><p>存的不多，不想花钱（了解了一下,当图床用的话没多少钱）和费事。<br>Amazon s3、Google storage；<br>七牛云、又拍云、腾讯云、阿里云、华为云都可以选</p><h3 id="静态资源托管平台做图床："><a href="#静态资源托管平台做图床：" class="headerlink" title="静态资源托管平台做图床："></a>静态资源托管平台做图床：</h3><p><del><a href="https://gitee.com/"><strong>Gitee</strong></a></del>；<br>据说图片<strong>超过1M访问要登录账号</strong>，虽然我图片很少有1M以上的，但是放弃。<br><a href="https://github.com/"><strong>GitHub</strong></a>;<br>邮箱注册，方便快捷，没有乱七八糟的认证。服务器在国外，访问较慢。可以使用cdn缓存来解决访问慢的问题。</p><h3 id="第三方图床"><a href="#第三方图床" class="headerlink" title="第三方图床"></a><del>第三方图床</del></h3><p>sm.ms；imgchr（路过图床）；聚合图床等。</p><h3 id="社交网站图床"><a href="#社交网站图床" class="headerlink" title="社交网站图床"></a><del>社交网站图床</del></h3><p><del>微博图床</del>（没法用了，官方被嫖太多了，限制外链了）、qq空间等。</p><h3 id="自建图床"><a href="#自建图床" class="headerlink" title="自建图床"></a>自建图床</h3><p>有条件的时候尝试一下自己搭个图床，自己做的东西才是最放心，不用担心跑路。</p><h1 id="博客发布"><a href="#博客发布" class="headerlink" title="博客发布"></a>博客发布</h1><p><strong>GitHub Pages</strong><br>GitHub提供页面化服务，可以把托管的静态资源渲染成网页。（使用Pages服务的仓库名称特定，一个账号限制一个）其实，这个服务的初衷是帮助用户，直观的展示自己的项目结构，毕竟看文件夹和代码太不直观了。用于博客建站也算是个邪用，发发文字为主的内容应该问题不大，要是白嫖服务器太狠也对网站发展不好，希望好的平台能有好发展吧。</p><p><del><strong>Gitee Pages</strong></del><br>使用该服务要身份证实名认证，这我理解，网络治理监管需要嘛，谁知道会不会有人用这个服务发布不良信息呢。但是要求<strong>手持身份证，人脸和身份证都要拍</strong>，实在太膈应我了，哪怕你能够支付宝、微信啥的快捷认证我都用了。而且除了服务器在国内访问快些，其他方面真的难用，不仅是Pages服务。</p><p>还有一些其他的托管平台或提供页面发布的方式，可以自行寻找。</p><h1 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><strong>Hexo主题——Fluid</strong><br>功能丰富，插件多，简洁好看，我很喜欢。<br><strong>Gridea主题——Breek</strong><br>当初看到这个主题，也很喜欢它排版和样式，可惜没有分类和侧边目录。</p><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p><del><strong>gittalk</strong></del><br>基于GitHub issue，需要登录GitHub账号才能评论，而且申请权限太多了，所有公共仓库的读写权限。<br><strong>valine评论</strong><br>基于LeadCloud，轻量的评论系统，用的人也多，有了问题也好问。</p><h2 id="看板娘喵"><a href="#看板娘喵" class="headerlink" title="看板娘喵"></a>看板<del>娘</del>喵</h2><p>参考：<br><a href="https://www.xifenghhh.top/article/hexo-fluid-theme-beautification-with-live2d-kanban-girl/">Hexo Fluid主题美化之添加Live2D看板娘</a> </p><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a></p><h2 id="封面制作"><a href="#封面制作" class="headerlink" title="封面制作"></a>封面制作</h2><p><a href="https://colorfu.art/editor"><strong>colorfu</strong></a><br>一个很好用的在线背景图制作网站</p>]]></content>
    
    
    <categories>
      
      <category>博客志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2021/hello-hexo/"/>
    <url>/2021/hello-hexo/</url>
    
    <content type="html"><![CDATA[<p>今年初萌生了写个人博客的想法，在看到网络上一篇篇优秀的博文之后，受到吸引，便想着自己也搭建一个属于自己博客。在了解了一些搭建博客的相关知识之后，我选择了用Hexo框架进行写作。</p><span id="more"></span><h1 id="为什么想要搭建个人博客"><a href="#为什么想要搭建个人博客" class="headerlink" title="为什么想要搭建个人博客"></a>为什么想要搭建个人博客</h1><p>正如开篇所说，想要写博客最初是受到了其他优秀博客的吸引，想要自己拥有一个个人博客，也有“这样很酷”、“学编程就应该写博客”这样的想法在。此外，我认为写博客也能够很好的帮助我，梳理学习过程中的思路，为知识做系统性的总结和归纳。很多时候，好像明白了一个知识点，但下笔记录，系统梳理的时候总是能发现很多的不足，这时候我才意识到，自己原来知识“似懂非懂”。</p><p>同样是记录学习过程，整理自己的知识体系，笔记也能够承担相应的职能，为什么非要写博客呢？对此我看到过很多的观点，有人觉得博客搭建之后更加直观，笔记查看不如博客来的方便，有人认为博客更便于分享等等。这些都是促使我选择博客的原因之一，但最重要的是，写博客带给我一种“仪式感”。我花费了时间精力，学习怎么搭建博客，排除了过程中的种种问题，最后搭建了一个博客，自然不会轻易的将它荒废掉。或许这就是，“不是轻易得到的，往往更加珍惜吧”。</p><p>确定了写博客的目标，那么在哪写博客呢？像是CSND、博客园、简书等都是很经典的博客写作平台，我在查资料的时候，经常从这些平台搜寻相关博文，它们也帮助我解答了许多学习遇到的困难。但，它们有着界面不简洁，有强制广告区等问题。这也无可厚非，毕竟是需要盈利的平台。但出于个人书写的需要，我希望除了自己的文章和笔记之外，没有广告推广之类的干扰。那么搭建一个个人博客，就是一个不错的选择。</p><h2 id="为什么选Hexo"><a href="#为什么选Hexo" class="headerlink" title="为什么选Hexo"></a>为什么选Hexo</h2><p>在看过一些网上搭建博客的教学文章和视频后，在动态博客和静态博客两大类中，我选择了后者。理由很简单，动态博客需要服务器支持，要维护数据库，虽然添加功能要比静态博客方便，但对于单纯写作来说，动态博客搭建太麻烦了，我也不是要搭建一个博客交流社区。每年维护服务器什么的也是一笔开支，目前没有富裕的条件去维持。静态博客搭建更加简单快捷，现有的静态博客框架非常多，部署简单，虽然不能像动态博客那样后台管理，但也不容易出问题，更安全。都是静态文件，要是有问题实在找不出来，直接干掉文件夹重来就好了（懒人一个）。</p><p>在许多的静态博客框架中，我选择了Hexo。Hexo用的人很多，遇到问题我可以很快的找到解答，许多问题大家都遇到过。其次，Hexo支持的插件和拓展丰富，还有相比其他静态框架，据说渲染速度还是很优秀的。hugo的速度公认最快，很多博主也说把自己的博客迁移到Hugo上了，我了解之后还是选择了用Hexo，渲染慢一点我也能接受，主要hugo偏后端一些，基于Go语言，我不会Go啊。Hexo对html标签比较友好，我了解一些，在一些小地方还能改改。虽说Hexo速度不及Hugo，但据一些Hexo重度用户说，除非写了上千篇文章，还不至于渲染慢的受不了。正好电脑上，也有Node.js的环境，就Hexo完事了。还有就是我很喜欢，Fulid这个Hexo主题，Hexo还有中文社区，查看文档也更方便。（还是要好好提高英文水平）</p><p>算了，与其纠结框架选择，不如好好写内容，别人Hexo搭建的博客也用的蛮好。</p><h2 id="Gridea使用感受"><a href="#Gridea使用感受" class="headerlink" title="Gridea使用感受"></a>Gridea使用感受</h2><p>PS：在此之前，我用过Gridea，也是一个静态博客写作工具。它简直是懒人福音，不同于Hexo需要命令行操作和git环境，Gridea几乎所有写作都可以在客户端完成，可以自定义主题。配置好仓库后，本地渲染预览之后，点击同步直接推送到GitHub（或者其他托管平台）上，简洁方便。但是，它的同步实在是太容易出错了，经常推送数次都失败，最后我还是只有手动“git push”。此外，用的人比较少（我感觉的），使用过程出现很多问题，我都找不到解答，网上很多只有搭建教程，就只说了怎么搭建。主题也比较少，我浏览了官方网站的所有主题，没有支持文章分类的主题，也可能是Gridea本身就没开发分类这个功能。这对我来说太难受了，文章查找起来很混乱。表签代替分类，也不是不行，但是标签本来就是标注文章涉及了哪些个方面，把标签当分类就不能打多个标签，而且也不能多级分类。</p><p>在使用了一段时间的Gridea之后，我决定换一个框架了。之前写的博客，保留在原来仓库，正好借换框架，新建一个博客把内容细化，之前的博客就用来记录生活和个人兴趣相关的内容。新博客针对性的写学习笔记。之前那个Gridea的Breek主题，我也蛮喜欢的，我一开始折腾了好久，把主题源码都看了一遍，改了不少自己想要的细节。可惜没有文章分类和侧边目录，一旦文章比较长，看起来就很费劲。</p><h1 id="搭建过程踩坑记录"><a href="#搭建过程踩坑记录" class="headerlink" title="搭建过程踩坑记录"></a>搭建过程踩坑记录</h1><h2 id="部署hexo博客"><a href="#部署hexo博客" class="headerlink" title="部署hexo博客"></a>部署hexo博客</h2><p>静态博客搭建，主要有这么几个部分：静态博客框架、托管平台、域名（可选）、第三方拓展（可选）<br>我选择的Hexo框架，托管平台为GitHub，使用GitHub Pages服务把我的静态资源渲染成页面。这种方式搭建博客，步骤如下：</p><h3 id="1-Node-js-下载安装"><a href="#1-Node-js-下载安装" class="headerlink" title="1.Node.js 下载安装"></a>1.Node.js 下载安装</h3><p><a href="https://nodejs.org/en/download/">Node.js下载地址</a><br><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">安装教程</a><br>Hexo框架是基于Node.js的，没有对应环境无法运行。下载安装Node.js，基本没什么问题，对着安装步骤，一路默认安装就好了，就是注意如果是Windows，不要把它装到C盘，除非你C盘真的大不在乎被软件塞。安装好之后，打开命令行输入 <code>node -v</code>，查看是node否安装正确（有版本号说明对了），再输入<code>npm -v</code>查看包管理器是否安装正确。这两个命令是Hexo运行必须的。<br><code>v14.15.3</code> node.js版本<br><code>6.14.9</code> npm版本<br>安装时，尽量非测试版本的最新版。</p><h3 id="2-git-下载安装"><a href="#2-git-下载安装" class="headerlink" title="2.git 下载安装"></a>2.git 下载安装</h3><p><a href="http://git-scm.com/downloads">git下载地址</a><br><a href="https://www.runoob.com/git/git-install-setup.html">git下载教程</a><br>同样安装好之后，检查版本号。命令行输入 <code>git --version</code> 得到版本信息<br><code>git version 2.23.0.windows.1</code></p><h3 id="3-本地搭建hexo博客"><a href="#3-本地搭建hexo博客" class="headerlink" title="3.本地搭建hexo博客"></a>3.本地搭建hexo博客</h3><p><a href="https://hexo.io/zh-cn/">Hexo中文版网址</a><br><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><h4 id="1-下载Hexo客户端"><a href="#1-下载Hexo客户端" class="headerlink" title="1)下载Hexo客户端"></a><strong>1)下载Hexo客户端</strong></h4><p><code>npm install hexo-cli -g</code><br>该命令中的 -g 参数表示全局安装，也可以选择安装到指定文件夹，在将hexo命令添加到环境变量。但明显全局安装不易出错。如果不再使用需要卸载Hexo，在命令行输入<br><code>npm uninstall hexo-cli -g</code><br>如果由于网络不畅导致安装失败，重新输入下载命令进行安装即可。实在太慢，就安装一个淘宝的镜像源，命令行输入<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>之后下载操作把<code>npm</code>改成<code>cnpm</code></p><h4 id="2-检查hexo命令"><a href="#2-检查hexo命令" class="headerlink" title="2)检查hexo命令"></a><strong>2)检查hexo命令</strong></h4><p>命令行输入<code>hexo -v</code>检查版本号</p><h4 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="3)初始化hexo"></a><strong>3)初始化hexo</strong></h4><p>选择一个文件夹，在此处进入命令行，输入<br><code>hexo init XXX</code><br>XXX 是博客文件夹名称，该命令会创建一个名为’XXX’的文件夹，里面是Hexo博客的源文件。以后一旦出现任何问题，如果实在无法解决，直接把该文件夹干掉重来就好，不过记住之前把自己的文章备份好。</p><p><strong>踩坑</strong>：windows下，在命令行创建文件夹<code>mkdir XXX</code>，进入之后，执行<code>hexo init</code>。或者 直接<code>hexo init XXX</code>。在图形界面用鼠标创建XXX文件夹，进入执行<code>hexo init</code>，总是初始化失败，不知道为啥。</p><h4 id="4-渲染文件启动hexo"><a href="#4-渲染文件启动hexo" class="headerlink" title="4)渲染文件启动hexo"></a><strong>4)渲染文件启动hexo</strong></h4><p>输入<br><code>hexo g</code> 渲染静态网页<br>渲染完成后，输入<br><code>hexo s</code>  启动hexo本地服务器<br>成功启动后，打开本地4000端口查看生成的博客网页</p><p>到此hexo本地搭建完成，如何生成新文章，更换主题，先不管。相关操作，参考官方文档。</p><h3 id="4-部署hexo博客到GitHub"><a href="#4-部署hexo博客到GitHub" class="headerlink" title="4.部署hexo博客到GitHub"></a>4.部署hexo博客到GitHub</h3><p>注册GitHub账号 —&gt; 新建仓库（仓库必须名为：用户名.github.io）—&gt; 初始化仓库 —&gt;启动GitHub Pages服务<br>完成之后，GitHub会分配一个<code>用户名.github.io</code>的域名给你</p><p>这个过程简单，网上参考流程很多。</p><p>在完成GitHub Pages服务启动之后，回到博客目录下，安装hexo自动部署工具。<br>输入<code>npm install hexo-deployer-git --save</code><br>安装完成后，修改博客目录下的，<code>_config.yml</code> 文件<br>打开文件，找到deploy，修改下面的字段：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">tpye:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/用户名/仓库名.git</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></div></td></tr></table></figure><p>类型改为git，repo是仓库地址，branch为分支<br>注意冒号为英文冒号，冒号后有空格。</p><p>完成之后，回到博客目录，输入<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code><br>清理之前的渲染文件，重现渲染 推送到远程仓库，第一次推送会要求输入GitHub用户名和密码<br>推送完成成功部署到GitHub仓库，在浏览器输入<code>用户名.github.io</code>（之前的域名），就能看到生成的博客网页了。</p><p><strong>踩坑</strong><br>修改hexo配置文件”_config.yml” 中仓库地址，我 使用https地址总是报错<br><code>fatal: unable to access &#39;https://github.com/xxx/xxx.github.io/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</code><br>按照网上解决方案，改用ssh地址：<br><code>git@github.com:xxx/xxx.github.io.git</code><br>但是依旧报错，我检查之后报错信息后，发现是和我另一个git账号的ssh信息冲突了。我之前保存了另一个GitHub账号的ssh密钥在电脑上。<br>解决方案，删除已有的ssh密钥，重新为两个账号配置ssh密钥。<br>参考博文<a href="https://blog.csdn.net/u010132177/article/details/104825446">同一台电脑怎样配置并使用多个git账号</a><br>最后推送成功到GitHub上</p><h3 id="5-hexo常用命令"><a href="#5-hexo常用命令" class="headerlink" title="5.hexo常用命令"></a>5.hexo常用命令</h3><p><code>hexo cl</code>清除上次渲染的文件<br><code>hexo g</code> 渲染页面<br><code>hexo s</code>启动本地hexo<br><code>hexo d</code> 推送到远程仓库</p><p><code>hexo new  xxx</code> 新建文章<br><code>hexo new page xxx</code> 新建页面</p><h2 id="优化hexo博客"><a href="#优化hexo博客" class="headerlink" title="优化hexo博客"></a>优化hexo博客</h2><h3 id="1-主题更换"><a href="#1-主题更换" class="headerlink" title="1.主题更换"></a>1.主题更换</h3><p>首先，去hexo官网的主题页面挑选一个喜欢的主题，在主题的GitHub仓库下载主题文件夹压缩包，解压之后，将主题文件夹，放到博客根目录的“themes”文件夹下。</p><p>然后，修改”_config.yml”中的”theme”字段，把主题名称更换为，刚刚下载的主题文件夹的名字。比如：<br><code>theme: fluid</code><br>之后保存文件，重新渲染页面，启动hexo，就能看到主题已经被更换了。</p><p>每个主题的自定义设置不同，具体看主题仓库的说明文件，修改对应代码，把主题改成自己想要的样子。</p><h3 id="2-Front-Matter"><a href="#2-Front-Matter" class="headerlink" title="2.Front Matter"></a>2.Front Matter</h3><p>文章的Front Matter，指定个别文件的变量，比如发布日期，标题，更新日期，分类和标签等，具体的属性设置参考官方说明：<br><a href="https://hexo.io/zh-cn/docs/front-matter">Front Matter</a></p><p>常用的一些参数：</p><p><code>title: xxx</code>    文章标题<br><code>index_img: url</code>    文章缩略图，url为图片地址<br><code>banner_img: url</code>    文章头图，url为图片地址<br><code>date:xx/xx/xx xx:xx:xx</code>  文章发布日期<br><code>author: xxx</code>    作者<br><code>categories: xxx</code>    分类/多个分类用 - 相隔<br><code>tags: xx</code>    标签/多个标签用 - 相隔</p><p>关于分类：Hexo默认没有同级分类</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-string">-sport</span><br><span class="hljs-string">-ball</span><br></code></pre></div></td></tr></table></figure><p>这样，ball类会被认为是sport的子类</p><p>如果需要同级分类用英文方括号把分类名括起来</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-string">-[sport,ball]</span><br><span class="hljs-string">-[art]</span><br></code></pre></div></td></tr></table></figure><p>这样，sport 和 art同级，ball是sport的子类</p><h3 id="3-添加about页面"><a href="#3-添加about页面" class="headerlink" title="3.添加about页面"></a>3.添加about页面</h3><p>特别注意的是，layout，该属性指定了文章的布局。默认的博客结构中是没有”about”页面的，但许多主题都会自带”about”页面，博客也通常有一个”about”页面来说明博客和作者的一些基本信息。</p><p>在博客根目录打开命令行（可以用Git Bash），输入<code>hexo new page about</code> 新建一个about页面<br>在博客根目录的source文件夹中就会出现一个about文件夹，里面有一个index.md文件，在文件的Front Matter部分添加，layout: about 以此指定布局为”about page”，如果不指定，主题会默认这是自定义页面布局”custom page”。<br>再在，主题文件夹的”_config.yml”中启用about页面。（每个主题配置方法有所不同）</p><h3 id="4-自定义域名"><a href="#4-自定义域名" class="headerlink" title="4.自定义域名"></a>4.自定义域名</h3><p>首先从域名提供商那购买一个域名，我是从阿里云买的域名，拥有域名之后，设置域名解析。在解析类型那选择 CNAME类型，这种类型是把购买的域名解析到另一个域名，正是我们需要的，因为我们已经有了GitHub Pages提供的 XXX.github.io域名了。把域名解析到 GitHub分配的域名。</p><p>登录GitHub账号，在Pages的Custom site中填入刚刚完成解析的域名，点击save保存。<br>这时，仓库中多了一个“CNAME”文件，里面写的就是自定义的域名。<br>回到hexo博客根目录，打开source文件夹，新建一个文本文件，把自定义域名写入，保存。修改文件名为“CNAME”，注意没有后缀名，就叫CNAME。<br>回到博客根目录，修改_config.yml文件，在skip_render: 后面写上CNAME，注意冒号后有空格<br>skip_reder: 后面指定的文件，在渲染时会被跳过，这样一来，CNAME文件就不会在渲染时被修改。</p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>图床选择参考：<br><a href="https://blog.cyfan.top/p/eb490c73.html">图床的千层套路</a> by: 陈YFの博客<br>ps: 我在寻找博客框架时，正好看到了该文作者的博客，使用的正是Hexo的Fluid主题，我才决定用Hexo的，看到的瞬间就喜欢上了。</p><p>Fluid主题优化参考：</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">Fluid主题 添加评论</a></p><p><a href="https://hexo.fluid-dev.com/posts/fluid-footer-custom/">Fluid 页脚增加网站运行时长</a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>博客框架看了五六个，实际上手了两个框架，配置主题，修改主题，推送GitHub，自定义域名，修改样式，配置评论插件等等，折腾了一大圈，猛然觉察自己似乎偏离了搭博客的初心。其实纠结于用什么主题、什么框架并不重要，只要它能用，够用，不会随随便便出问题就行了，最主要是坚持写博客的毅力，持之以恒去写作。无论框架多么高级，界面多么优美，失去了内容的支撑，也不过是华而不实的空壳子。</p><p>希望自己，坚持写作，用内容装点这费了些力气才搭建起的博客。</p>]]></content>
    
    
    <categories>
      
      <category>博客志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arduino+ESP8266的远程控制小车</title>
    <link href="/2021/Arduino-ESP8266-Car/"/>
    <url>/2021/Arduino-ESP8266-Car/</url>
    
    <content type="html"><![CDATA[<p>简单介绍如何利用Arduino单片和ESP8266开发板，结合物联网云平台，制作一款能远程遥控的小车。<br>KeyWords：单片机控制、WiFi、远程遥控、手机App</p><span id="more"></span><h1 id="Arduino-ESP8266的远程控制小车"><a href="#Arduino-ESP8266的远程控制小车" class="headerlink" title="Arduino+ESP8266的远程控制小车"></a>Arduino+ESP8266的远程控制小车</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><h3 id="小车主控板：Arduino-UNO"><a href="#小车主控板：Arduino-UNO" class="headerlink" title="小车主控板：Arduino UNO"></a>小车主控板：Arduino UNO</h3><p>​        Aruduino平台于2005年诞生，两位就职于米兰设计学院的教授，希望开发一款具有软件开发功能的开源的硬件实验平台，于是在他们的合作下，Arduino应运而生。Arduino的编程的语言脱胎于C，如果你有了C语言的学习经验的话，在了解了基本的语言特点和语法之后，便能够非常快速的在Arduino上进行独立的开发工作。关于Arduino的语言，主要有一下两部分，其一是setup()函数，该函数的作用只要在于对系统进行初始化，对相应的引脚进行定义，比如设置输入还是输出模式。第二部分是loop()函数，该函数是用来编写对应的功能的，同时loop()函数将启动硬件部分。不仅如此，Arduino拥有丰富的库文件，分为：官方提供和开发者自定义两种类型。 </p><p>​        正如上文提到的，Arduino同时兼具软件开发的功能，拥有着自己的软件开发环境——Arduino IDE。它最为显著的特点就是可以跨多个平台运行，极大方便了使用。目前支持的平台包括：Linux、Windows和MacOS等。Arduino IDE是针对Arduino开发板的一个集成开源的编译软件，操作界面简单、语言风格与C语言相近、使用的库文件是开源的并且简单的代码可以直接通过串口进行下载。对于使用Arduino的开发者来说，这是一款首选的开发环境。<br>   <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071605373.png" alt="ArduinoIDE"></p><p>​        ArduinoIDE是基于processing IDE开发的，是初学者十分的友好，能够快速的掌握，并具有很高的灵活性。Arduino的语言对于avr-gcc库二次封装，因而不需要太多的单片机和编程基础，便可以进行快速的开发。它的工作流程为，在开发者编写好代码，编译后，将语言转换成C++，再用avr-gcc将编译语言转换成二进制，这样一来，开发者编写的内容才能够背Arduino的硬件识别，程序才能够运行。这串代码通过USB接口连接到电脑，再上传到Arduino的存储器进行存储。</p><p>​        在开发者使用Arduino IDE的时候，要做好以下的准备工作：在PC端下载对应硬件的驱动，选择合适的端口。这些步骤完成之后，便可开始程序的编写。Arduino还有第三方的图形化编程软件，极大地降低了对开发者的编程能力的要求，只要能够符合逻辑的设计出功能，按照规定的方式设置对应的参数，便可以下载程序到硬件开发板进行使用。</p><p><a href="https://www.arduino.cc/en/software">Arduino软件下载</a><br><a href="https://www.arduino.cn/">Arduino中文社区</a></p><p>​        小车选用的是Arduino UNO的开发板，搭载芯片为ATmega328p。</p><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071605635.png" alt="ArduinoUNO"></p><p>​        同时为了方便对控制小车其他配件，选用了一块配套的功能转接板，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071606505.png" alt="功能转接板"></p><p>​                                                                                                        </p><h3 id="远程连接模块：ESP8266开发板"><a href="#远程连接模块：ESP8266开发板" class="headerlink" title="远程连接模块：ESP8266开发板"></a>远程连接模块：ESP8266开发板</h3><p>小车采用ESP-12E开发板（NoteMCU）作为WIFI连接的模块，通过该块开发板连接物联网云平台，实现远程的控制实现。<br>        <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071610875.jpg" alt="EPS8266">    </p><h3 id="其他配件"><a href="#其他配件" class="headerlink" title="其他配件"></a>其他配件</h3><p>小车还需要的配件包括：四个直流电机，底盘，车轮，螺丝（若干），铜柱（若干），电池盒，可充电电池。</p><h2 id="云平台选择——点灯科技（Blinker）"><a href="#云平台选择——点灯科技（Blinker）" class="headerlink" title="云平台选择——点灯科技（Blinker）"></a>云平台选择——点灯科技（Blinker）</h2><p><a href="https://www.diandeng.tech/home">官网首页</a></p><p><a href="https://www.diandeng.tech/doc">开发文档</a></p><h2 id="远程控制设计"><a href="#远程控制设计" class="headerlink" title="远程控制设计"></a>远程控制设计</h2><h3 id="小车控制"><a href="#小车控制" class="headerlink" title="小车控制"></a>小车控制</h3><p>远程控制功能主要分为两个主要部分，分别是对小车的动作控制和云平台连接。</p><p>小车的行动通过控制电机的转速来实现，单片机的I/O口输出不同的信号，改变驱动电路中PWM的比例值，进而对电机的转速进行调控。将对应的电机状态用函数进行封装，配合不同指令调用对应的函数来实现对小车的控制。</p><p>小车基本动作的函数如下表所示：</p><p>​                                                                                        小车基本动作函数</p><table><thead><tr><th>函数名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>run()</td><td>小车向前进</td><td>左右电机前进</td></tr><tr><td>brake()</td><td>小车停止</td><td>左右电机停止</td></tr><tr><td>left()</td><td>小车左转</td><td>右电机前进左电机停止</td></tr><tr><td>right()</td><td>小车右转</td><td>右电机停止左电机前进</td></tr><tr><td>back()</td><td>小车后退</td><td>左右电机反转</td></tr></tbody></table><h3 id="云平台连接"><a href="#云平台连接" class="headerlink" title="云平台连接"></a>云平台连接</h3><p>云平台远程连接采用ESP-12E开发板实现，首先通过ESP-12E板和物联网云平台（采用的是Blinker平台）进行远程连接，首先给开发板刷入Blinker的固件，当设备连接启动后，Arduino板通过串口向ESP-12E开发板发送AT指令，进行WIFI连接。连接成功后，就可以通过手机端向云平台发送指令，再由云平台发送给ESP-12E，Arduino通过串口读取指令，调用相应的动作函数。</p><p>​                                                                                            AT指令字段说明</p><table><thead><tr><th>AT指令</th><th>BLINKER_WIFI=0</th><th>3275431b24545</th><th>f55</th><th>bruce6545555</th></tr></thead><tbody><tr><td>说明</td><td>模块工作于透传模式</td><td>绑定设备的密钥</td><td>WIFI名称</td><td>WIFI密码</td></tr></tbody></table><p>Bilnker云平台远程连接，主要分为新建组件、设置回调函数、绑定组件与回调函数三个步骤，主要的函数说明如下。</p><p>​                                                                                        远程连接主要函数说明</p><table><thead><tr><th>函数名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>BlinkerButton ButtonRun(“btn-run”);</td><td>创建Button对象，键值为“btn-run”</td><td>对应Blinker app上的按键控件</td></tr><tr><td>void  buttonRun_callback(const String &amp; state)</td><td>获取按键的状态</td><td>根据按键的触发状态执行对应语句</td></tr><tr><td>ButtonRun.attach(buttonRun_callback)</td><td>绑定控件和对应的回调函数</td><td></td></tr></tbody></table><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="小车控制部分"><a href="#小车控制部分" class="headerlink" title="小车控制部分"></a>小车控制部分</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment">  前进  按下发出 ONA  </span><br><span class="hljs-comment">  后退：按下发出 ONB  </span><br><span class="hljs-comment">  左转：按下发出 ONC  </span><br><span class="hljs-comment">  右转：按下发出 OND  </span><br><span class="hljs-comment">  停止：按下发出 ONE  </span><br><span class="hljs-comment">************************************************/</span><br><span class="hljs-keyword">int</span> Left_motor=<span class="hljs-number">8</span>;     <span class="hljs-comment">//左电机(IN3) 输出0  前进   输出1 后退</span><br><span class="hljs-keyword">int</span> Left_motor_pwm=<span class="hljs-number">9</span>;     <span class="hljs-comment">//左电机PWM调速</span><br><br><span class="hljs-keyword">int</span> Right_motor=<span class="hljs-number">11</span>;    <span class="hljs-comment">//右电机(IN1)  输出0  前进   输出1 后退</span><br><span class="hljs-keyword">int</span> Right_motor_pwm=<span class="hljs-number">10</span>;    <span class="hljs-comment">// 右电机PWM调速</span><br><br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">18</span>];<span class="hljs-comment">//串口缓冲区的字符数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>  <span class="hljs-comment">//设定串口和引脚模式</span></span><br><span class="hljs-function"></span>&#123;<br>     Serial.begin(<span class="hljs-number">9600</span>);<br>     Serial.flush();<span class="hljs-comment">//清空串口缓存</span><br>     <br>     Serial.println(<span class="hljs-string">&quot;AT+BLINKER_WIFI=0,3275431b255e,f55,bruce6545555&quot;</span>);<br><br>     pinMode(Left_motor,OUTPUT); <span class="hljs-comment">// PIN 8 8脚无PWM功能</span><br>     pinMode(Left_motor_pwm,OUTPUT); <span class="hljs-comment">// PIN 9 (PWM)</span><br>     pinMode(Right_motor_pwm,OUTPUT);<span class="hljs-comment">// PIN 10 (PWM) </span><br>     pinMode(Right_motor,OUTPUT);<span class="hljs-comment">// PIN 11 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>     <span class="hljs-comment">// 前进</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);   //执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brake</span><span class="hljs-params">()</span>         <span class="hljs-comment">//刹车，停车</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>  digitalWrite(Right_motor_pwm,LOW);  <span class="hljs-comment">// 右电机PWM 调速输出0      </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br><br>  digitalWrite(Left_motor_pwm,LOW);  <span class="hljs-comment">//左电机PWM 调速输出0          </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span>         <span class="hljs-comment">//左转(左轮不动，右轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">110</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,LOW);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spin_left</span><span class="hljs-params">()</span>         <span class="hljs-comment">//左转(左轮后退，右轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机前进</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  digitalWrite(Left_motor,HIGH);  <span class="hljs-comment">// 左电机后退</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">right</span><span class="hljs-params">()</span>        <span class="hljs-comment">//右转(右轮不动，左轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(Right_motor,LOW);  <span class="hljs-comment">// 右电机不转</span><br>  digitalWrite(Right_motor_pwm,LOW);  <span class="hljs-comment">// 右电机PWM输出0     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">0</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">110</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spin_right</span><span class="hljs-params">()</span>        <span class="hljs-comment">//右转(右轮后退，左轮前进)</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,HIGH);  <span class="hljs-comment">// 右电机后退</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机PWM输出1     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">50</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,LOW);  <span class="hljs-comment">// 左电机前进</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">50</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);//执行时间，可以调整    </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">back</span><span class="hljs-params">()</span>          <span class="hljs-comment">//后退</span></span><br><span class="hljs-function"></span>&#123;<br>  digitalWrite(Right_motor,HIGH);  <span class="hljs-comment">// 右电机后退</span><br>  digitalWrite(Right_motor_pwm,HIGH);  <span class="hljs-comment">// 右电机前进     </span><br>  analogWrite(Right_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <br>  <br>  digitalWrite(Left_motor,HIGH);  <span class="hljs-comment">// 左电机后退</span><br>  digitalWrite(Left_motor_pwm,HIGH);  <span class="hljs-comment">//左电机PWM     </span><br>  analogWrite(Left_motor_pwm,<span class="hljs-number">90</span>);<span class="hljs-comment">//PWM比例0~255调速，左右轮差异略增减</span><br>  <span class="hljs-comment">//delay(time * 100);   //执行时间，可以调整    </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Serial.available() &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//Serial.available()返回串口收到的字节数</span><br>    &#123;<br>       <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>       delay(<span class="hljs-number">100</span>);<span class="hljs-comment">//延时等待串口收完数据，否则刚收到1个字节时就会执行后续程序</span><br>       <span class="hljs-keyword">int</span> numChar = Serial.available();<br>       <span class="hljs-keyword">if</span>(numChar &gt; <span class="hljs-number">15</span>)<span class="hljs-comment">//确认数据不会溢出，应当小于缓冲大小</span><br>       &#123;<br>         numChar = <span class="hljs-number">15</span>;<br>        &#125;<br>       <span class="hljs-keyword">while</span>(numChar--)<br>      &#123;<br>          buffer[index++] = Serial.read();<span class="hljs-comment">//将串口数据一字一字的存入缓冲</span><br>      &#125;<br>      Serial.println(buffer);<br>      splitString(buffer);<span class="hljs-comment">//字符串分割</span><br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">splitString</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>       Serial.print(<span class="hljs-string">&quot;Data entered:&quot;</span>);<br>       Serial.println(data);<br>       <span class="hljs-keyword">char</span> *parameter;<br>       parameter = strtok(data, <span class="hljs-string">&quot; ,&quot;</span>);<span class="hljs-comment">//string token，将data按照空格或者,进行分割并截取</span><br>       Serial.println(parameter);<br>    <span class="hljs-keyword">while</span>(parameter != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    setMove(parameter);<br>    parameter = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; ,&quot;</span>);<span class="hljs-comment">//string token，再次分割并截取，直至截取后的字符为空</span><br>    Serial.println(parameter);<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">16</span>; x++)<span class="hljs-comment">//清空缓冲</span><br>  &#123;<br>   buffer[x] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  &#125;<br>     Serial.flush();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMove</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;A&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;go forward!&quot;</span>); <br>      run();<br>  &#125;<br>  <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;B&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;go back!&quot;</span>); <br>      back(); <br> &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;C&#x27;</span>))<br>   &#123;<br>      Serial.println(<span class="hljs-string">&quot;go left!&quot;</span>); <br>      left();<br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;D&#x27;</span>))<br>   &#123;<br>     Serial.println(<span class="hljs-string">&quot;go right!&quot;</span>); <br>      right(); <br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;E&#x27;</span>))<br>   &#123;<br>      Serial.println(<span class="hljs-string">&quot;Stop!&quot;</span>); <br>      brake(); <br>  &#125;<br>    <span class="hljs-keyword">if</span>((data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&amp;&amp; (data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;F&#x27;</span>))<br>   &#123;<br>    Serial.println(<span class="hljs-string">&quot;Stop!&quot;</span>); <br>     brake();  <br>   &#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="远程连接部分（烧制在ESP-12E开发板）"><a href="#远程连接部分（烧制在ESP-12E开发板）" class="headerlink" title="远程连接部分（烧制在ESP-12E开发板）"></a>远程连接部分（烧制在ESP-12E开发板）</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLINKER_AT_MQTT</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Blinker.h&gt;</span></span><br><br><span class="hljs-comment">// 新建组件对象</span><br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonRun</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-run&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonBack</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-back&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonLeft</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-left&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonRight</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-right&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonStop</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-stop&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonOn</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-on&quot;</span>)</span></span>;<br><span class="hljs-function">BlinkerButton <span class="hljs-title">ButtonOff</span><span class="hljs-params">(<span class="hljs-string">&quot;btn-off&quot;</span>)</span></span>;<br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 按键回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonRun_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONA&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONA&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonBack_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONB&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONB&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonLeft_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONC&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;ONC&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonRight_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_PRESSED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;OND&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == BLINKER_CMD_BUTTON_RELEASED)&#123;<br>     Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      Serial.write(<span class="hljs-string">&quot;OND&quot;</span>);<br>      delay(<span class="hljs-number">1000</span>);<br>      Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>); <br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonStop_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   Serial.write(<span class="hljs-string">&quot;ONE&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonOn_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(<span class="hljs-number">2</span>,LOW);<br>   Serial.write(<span class="hljs-string">&quot;ONF&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buttonOff_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String &amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>   digitalWrite(<span class="hljs-number">2</span>,HIGH);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Blinker.begin();<br><br>    pinMode(<span class="hljs-number">2</span>,OUTPUT);<br>    <br>    ButtonRun.attach(buttonRun_callback);<br>    ButtonBack.attach(buttonBack_callback);<br>    ButtonLeft.attach(buttonLeft_callback);<br>    ButtonRight.attach(buttonRight_callback);<br>    ButtonStop.attach(buttonStop_callback);<br><br>    ButtonOn.attach(buttonOn_callback);<br>    ButtonOff.attach(buttonOff_callback);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// char ch=Serial.read(); // 读取输入的信息</span><br> <span class="hljs-comment">//Serial.print(ch);  //输出信息</span><br> <span class="hljs-comment">//delay(1000); </span><br>    Blinker.run();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arduino</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的自定义栈用C++实现</title>
    <link href="/2021/Custom-Stack/"/>
    <url>/2021/Custom-Stack/</url>
    
    <content type="html"><![CDATA[<p>用C++实现一个简单的自定义栈</p><span id="more"></span><h1 id="自定义一个栈（In-C-）"><a href="#自定义一个栈（In-C-）" class="headerlink" title="自定义一个栈（In C++）"></a>自定义一个栈（In C++）</h1><h2 id="在头文件-my-stack-h-中自定义栈"><a href="#在头文件-my-stack-h-中自定义栈" class="headerlink" title="在头文件 my_stack.h 中自定义栈"></a>在头文件 my_stack.h 中自定义栈</h2><h3 id="1-自定义栈的类的数据成员和公有函数"><a href="#1-自定义栈的类的数据成员和公有函数" class="headerlink" title="1. 自定义栈的类的数据成员和公有函数:"></a>1. 自定义栈的类的数据成员和公有函数:</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    Type *stk; <span class="hljs-comment">//起始地址</span><br>    <span class="hljs-keyword">int</span> MAXN;  <span class="hljs-comment">//最大容量</span><br>    <span class="hljs-keyword">int</span> top;   <span class="hljs-comment">//指向栈顶元素（下标）</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-keyword">int</span> size); <span class="hljs-comment">//初始化</span><br>    ~<span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;   <span class="hljs-comment">//判断空</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-comment">//判断满</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Type x)</span></span>;    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;           <span class="hljs-comment">//出栈</span><br>    <span class="hljs-function">Type <span class="hljs-title">get_top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//取栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;     <span class="hljs-comment">//栈大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;      <span class="hljs-comment">//最大容量</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-函数的定义："><a href="#2-函数的定义：" class="headerlink" title="2. 函数的定义："></a>2. 函数的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-keyword">int</span> size)<br>&#123;<br>    MAXN = size;<br>    stk = <span class="hljs-keyword">new</span> Type[MAXN];<br>    top = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-comment">//栈初始化</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Stack&lt;Type&gt;::~<span class="hljs-built_in">Stack</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> stk;<br>&#125; <span class="hljs-comment">//析构函数定义</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">full</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (top == MAXN - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;overflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">push</span>(Type x)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;overflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    stk[++top] = x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br>Type Stack&lt;Type&gt;::<span class="hljs-built_in">get_top</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;underflow&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stk[top];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">int</span> Stack&lt;Type&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">int</span> Stack&lt;Type&gt;::<span class="hljs-built_in">Max</span>() <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> -&gt;MAXN;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="在源文件my-stack-cpp中，实现栈的基本操作"><a href="#在源文件my-stack-cpp中，实现栈的基本操作" class="headerlink" title="在源文件my_stack.cpp中，实现栈的基本操作"></a>在源文件my_stack.cpp中，实现栈的基本操作</h2><h3 id="1-创建对象，实现栈的基本操作。"><a href="#1-创建对象，实现栈的基本操作。" class="headerlink" title="1. 创建对象，实现栈的基本操作。"></a>1. 创建对象，实现栈的基本操作。</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;my_stack.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, x, ele, i; <span class="hljs-comment">//最大长度；元素个数；元素；输入元素循环次数</span><br>enter:<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter max length of stack :&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter numbers of elements:&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (x &gt;= n)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;failed! numbers of elements must less than max length!&quot;</span> &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;please enter again!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">goto</span> enter;<br>    &#125;<br>    <span class="hljs-comment">/*创建栈对象*/</span><br>    <span class="hljs-function">Stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The max length is : &quot;</span> &lt;&lt; s.<span class="hljs-built_in">Max</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;enter your elements:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">/* 循环元素入栈 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x; i++)<br>    &#123;<br>        cin &gt;&gt; ele;<br>        s.<span class="hljs-built_in">push</span>(ele);<br>    &#125;<br>    <span class="hljs-comment">/* 元素出栈 */</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;stack size:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;output elements:&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">empty</span>() != <span class="hljs-literal">true</span>)<br>    &#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">get_top</span>() &lt;&lt; endl;    <span class="hljs-comment">//取栈顶元素</span><br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;stack size:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-用模板类的时候注意编写的格式"><a href="#2-用模板类的时候注意编写的格式" class="headerlink" title="2. 用模板类的时候注意编写的格式"></a>2. 用模板类的时候注意编写的格式</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">模板类外函数定义：<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数&gt;<br>函数类型 类名&lt;类型参数&gt;：：成员函数名（形参表）<br>&#123;<br>……<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/202111071603219.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>实践录</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
